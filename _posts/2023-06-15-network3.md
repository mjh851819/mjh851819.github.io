---
title: "네트워크 3-3 전송 계층: TCP의 Reliable Data Tranfer 2"

categories:
  - Network
tags:
  - Network
---

> 이 글은 KOCW에서 제공하는 한양대학교 이석복 교수님의 컴퓨터 네트워크 강의를 기반으로 내용을 정리하고 복습하기 위한 용도로 작성되었습니다.

> 이전강의에서 그대로 이어진다.

#### 3-1. flow control의 코너 케이스 처리

---

> 1.리시브 버퍼가 가득찼다. revWindow = 0

- 그렇다면 sender는 리시브 버퍼에 공간이 생길때까지 전송을 멈출것이다. 언제까지? - 리시버는 능동적으로 버퍼가 비었다고 응답해줄 수 없으므로 교착상태가 발생한다.
- 이를 해결하기 위해 상대방의 버퍼에 공간이 없더라도 주기적으로 데이터를 보내도록 설계된다.
- 적은 양의 데이터를 체크용으로 보냄으로써 버퍼가 비었음을 피드백 받을 수 있는 상황을 만드는 것이다.

> 2.세그먼트를 송신하는 상황에서 세그먼트의 크기는 항상 일정하나 세그먼트의 데이터 영역에 들어가는 데이터는 유동적이다. 애플리케이션에서 항상 데이터가
> 충분히 내려와서 매번 세그먼트의 데이터 영역을 꽉 채워서 보낼수 있다면 좋지만 애플리케이션에서 데이터가 느리게 내려올 수 있다.
> 그렇다면 세그먼트를 다 채우지 못한 상태로 송신할 텐데 이러한 주기를 어떻게 설정해야할까? 세그먼트의 용량을 모두 사용해서 보내는게 당연히 효율적이지만
> 데이터를 언제까지고 기다리는것은 또한 효율적이지 않다.

**전송자측**

- 우선 시작점에서 데이터가 1바이트라도 있으면 무조건 보낸다. 이후엔 데이터를 segment의 DATA에 채우면서 대기한다. 언제까지?
- 세그먼트의 최대 용량이 꽉 차거나 방금 보낸 세그먼트의 ACK를 받으면 다시 전송한다.
- 단순하지만 효율적인 알고리즘 (유명한 알고리즘으로 이름이 따로 있다).
  > 세그먼트의 용량이 가득차기 전에 ACK를 받는다는것은 그만큼 네트워크의 상황이 좋다는것이고 세그먼트 DATA 영역에 빈공간에 의해 생기는 오버헤드 정도는 감안할 수 있다는 의미다.

> 수신자측 (필수는 아니며 있으면 좋다)

- 리시브 버퍼의 남은 용량이 하나의 세그먼트최대 용량보다 적을때, delay ACKs(ex 500ms)
- 모든 세그먼트에 ACK를 보내지 말고 주기마다 ACK를 보낸다.

#### 4. Connection management

---

##### 4-1. 초기 연결

> 그렇다면 이러한 데이터 전송을 시작할때 송 수신자의 상호간 버퍼의 시작 시퀀스 넘버 등의 기본적인 정보 교환 및 초기화는 어떻게 관리될까?

- A와 B의 초기 연결과정은 권유 - 대답 의 2way- handshake로는 부족하다.
- 대답을 한 B가 상대방(A)이 대답을 확인했는지 알 방법이 없기 때문이다.

- 따라서 tcp 는 **3-way- handshake**를 사용한다.

![3-8](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/a738944d-8ad2-49e2-bfbd-72daa598bd97)

- 1way: A와B가 통신연결을 시도하는 세그먼트에서 A는 세그먼트의 SYNbit를 1로 설정하는데 이는 통신 연결을 시작할때만 사용되는 변수이다.(평소 통신에선 0) 이렇게 SYNbit와 초기 시퀀스 번호(x)만 담아서 data부분이 없는 세그먼트를 보낸다.(40바이트)
- 2way: 이후 헤더만 있는 세그먼트를 받은 B는 대답으로 똑같이 SYNbit를 1로 설정하고 자신의 시퀀스번호(y)와 함께 SYN의 응답이라는 의미의 ACKbit을 1로 설정하고 ACKnum(x+1)을 보낸다.
- 3way: A는 해당 대답을 잘 받았다는 의미로 ACKbit = 1로 설정하고 ACKnum = y + 1로 보냄으로써 상호 연결 준비를 마친다.
- 마지막 3way때는 A가 보내야할 데이터를 넣어서 보낼수도 있다. 이로써 전 단원에서 넘어갔던 세그먼트 헤더의 SYN과 ACK bit의 의미를 알아봤다.

##### 4-2. 연결 종료시

> A가 전송할 데이터가 더이상 없다.

![3-9](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/5ee15bf4-be36-4bdc-8069-fd08d6c6e2b0)

- SYN이나 ACK 처럼 연결을 끊을때 사용되는 FIN이라는 플래그가 있다. 이것을 1로 설정해서 보냄으로써 더이상 전송을 할 데이터가 없음을 B에게 알린다.

- 이때 tcp는 상호 데이터 교환이므로 B는 전송할 데이터가 남아있을수 있다.
- 따라서 이러한 세그먼트를 받은 B는 아직 전송할 데이터가 남아있기에 해당 FIN = 1인 세그먼트에 대한 응답만 보내고 아직 자신은 FIN=1의 세그먼트를 보내지 않는다.
- A는 이때부터 종료 대기 상태에 들어가고 B가보내는 데이터를 받기만한다.
- B의 데이터 전송이 다 끝났다면 B도 FIN=1의 세그먼트를 보내고 A는 해당 세그먼트의 대한 응답을 한 후 잠시 뒤에 연결을 끊는다.

##### 4-3. 연결을 끊을때 코너 케이스

> A는 B가 데이터를 모두 보냈음을 확인하고 왜 바로 연결을 끊지 않을까?

- 그 이유는 B가 데이터를 모두 보냈음에 대한 A의 대답이 loss될 가능성이 있기 때문이다.
- A가 대답을 보내자마자 연결을 닫아버리고 대답이 loss된다면 B는 대답을 듣지 못한채로 계속해서 FIN = 1의 세그먼트를 재전송할테지만 이미 A는 연결이 끊어져서
  대답을 할 수 없다.
- 따라서 B의 재전송이 올 수 있는 시간만큼 기다린 후에 연결을 완전히 종료한다. (B는 보낸 후에 바로 종료해도된다!)

#### 5. Congestion control 미리보기

- 지금까지 배운 flow control은 결론적으로 상대방의 rev buffer의 남은 용량만큼 send buffer의 window사이즈를 조절하는 것이다.
- 하지만 다음에 배울 congestion control 또한 같이 고려해줘야 하는데 상대방의 리시브 버퍼의 크기도 문제지만 네트워크 상황이 좋지 않다면 이 또한 고려해서 window의 사이즈를 조절해야하기 때문이다.
- 결과적으로 window의 사이즈는 네트워크의 상황을 고려한 window사이즈와 flow control에서 고려된 window사이즈의 최솟값으로 측정된다.
- 최근에는 컴퓨터의 성능들이 다들 좋아져서 rev buffer가 부족한 경우는 적다고 한다. 따라서 네트워크 상황에 따라 좌지우지 될 확률이 크다고 한다.
