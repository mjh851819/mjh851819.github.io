---
title: "BOJ 2225 합분해 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 2225 합분해 C++

문제

> 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.

> 덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.

입력

> 첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.

출력

> 첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.

---

_풀이_

dp테이블을 dp[i][j]라 했을때 "i개의 정수를 사용하여 j를 만드는 경우의 수" 로 테이블을 정의하여 해결했다.

초기에 dp[1][1~n]의 테이블은 1로 초기화했다. 숫자를 1개 사용해서 만들수 있는 경우는 모든 수에서 자기 자신 뿐이기 때문이다.

이후 i가 2부터는 다음과 같이 풀이했다.
ex. i가 3이며, n이 20일때 즉, 3개의 정수로 20을 만드는 경우의 수는?
0 + (2개의 정수로 20을 만드는 경우의 수)
1 + (2개의 정수로 19를 만드는 경우의 수)
2 + (2개의 정수로 18을 만드는 경우의 수)
...
20 + (2개의 정수로 0을 만드는 경우의 수)

위와같이 i가 증가할때마다 타일링 문제를 해결하듯이 앞에 올 수 있는 숫자만큼의 경우의 수를 모두 더해줌으로써 dp 테이블을 채워나갔다.

```c++

int n, k;
ll dp[205][205]; // 정수 i개를 쓰고, j를 만드는법

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> k;

    for (int i = 0; i <= n; i++) {
        dp[1][i] = 1;
    }
    //i개의 숫자를 사용하여
    for (int i = 2; i <= k; i++) {
        //j를 만드는 방법의 갯수
        for (int j = 0; j <= n; j++) {
            //경우의 수의 앞자리 숫자 0 ~ j의 모든 경우를 따지기 위해
            //0 - 20
            //1 - 19
            //2 - 18
            //...
            //의 경우의 수를 더하기 위해 아래 점화식 도출
            for (int k = 0; j - k >= 0; k++) {
                dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % 1000000000;
            }
        }
    }

    cout << dp[k][n];

}


```
