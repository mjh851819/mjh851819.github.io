---
title: "네트워크 8-1 네트워크 보안"

categories:
  - Network
tags:
  - Network
---

> 이 글은 KOCW에서 제공하는 한양대학교 이석복 교수님의 컴퓨터 네트워크 강의를 기반으로 내용을 정리하고 복습하기 위한 용도로 작성되었습니다.

## 네트워크 보안

#### 1. 네트워크 보안의 4가지 목표

---

1. Confidentiality: 기밀성, 주고받는 메세지를 sender와 receiver만 볼 수 있어야 함.
2. Authentication: 인증, sender와 receiver가 서로의 신원을 확신할 수 있어야함
3. Message Integrity: 메세지 무결성, 메세지가 중간에 조작되지 않고 상대편에게 도착해야함.
4. Access and Availability: 허가와 유효성

- TCP/IP에서는 4가지 중 어느하나도 지원해 주고 있지 않다.
- 결국 애플리케이션 계층에서 개발자가 보안 기능을 구현해야만 한다. (최신 ip프로토콜 버전에서는 포함되어있음)

#### 2. Cryptography: 암호화

---

![10-1](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/cd3cb7a8-f5bf-46ee-ad03-47eb9bc0a3d1)

- 위와 같이 앨리스와 밥이 메세지를 주고받는 중 트루디가 메세지를 갈취하려 한다.

- 앨리스와 밥은 plainText를 그대로 주고받으면 위험하다, 따라서 특정 방법으로 메세지를 암호화하여 둘만알고있는 key로 암호화된 메세지를 복호화 할 수 있어야한다.
- 암호화를 사용하면 트루디는 해당 메세지를 갈취해도 어떤 내용인지 알 수 없다.

#### 2-1. Symmetric key Cryptography

---

![10-2](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/5e87306c-ed44-43f1-82b3-bdc84be31623)

- 수신자와 송신자가 동일한 암호키를 가지며, 암호화와 복화에 서로 같은키를 사용한다. 굉장히 빠른속도로 암호화 / 복호화가 가능하다는 특징이 있다.
- Symmetric key Cryptography는 통신 초기에 암호키를 상호간에 어떻게 합의할 것인지가 가장 큰 문제점이다.

#### 2-2. Public key Cryptography

---

- Symmetric key Cryptography의 단점을 보완하기 위한 암호화 기법

- 모든 유저 각자의 public key와 private key 2가지의 키를 가진다.
- public key는 누구에게나 공개되어있기 때문에 A가 B에게 암호화 데이터를 전송할때 B의 공개키로 데이터를 암호화 할 수 있다.
- 이렇게 B의 공개키로 암호화 된 데이터는 B의 개인키로만 복호화가 가능하다.

- 이러한 기법으로 구현된 대표적인 RSA 암호화 알고리즘이 존재한다.
- RSA 암호화는 Symmetric key 암호화보다 속도가 느린 단점이 있는데 Symmetric key 와 RSA의 장점만을 채용해서 RSA 기법으로 Symmetric key 를 주고받고 이후의 데이터는 Symmetric key로 암호화해서 통신하는 최적화가 가능하다.

#### 3. Authentication

---

![10-3](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/66ca04b0-419b-4774-b6d9-98ce94f90bfb)

- 밥과 앨리스의 대화에서 밥은 대화상대가 앨리스가 맞는지 확인하고싶다.
- 위 그림처럼 밥은 앨리스에게 비밀문자를 전송하고 앨리스는 이를 자신의 개인키로 암호화해서 밥에게 보낸다. (signing, 서명이라고 부른다.)
- 밥은 앨리스의 공개키를 통해서 해당 문자를 복호화 할 수 있고 앨리스의 개인키는 앨리스만이 가지고 있으므로 서로의 신원을 확인할 수 있다.

- 하지만 애초부터 통신상대가 앨리스가 아닌 트루디였으며, 자신의 개인키로 암호화하고 자신의 공개키를 넘겨주면 밥은 이를 구분할 방법이 없다.
- 이러한 문제의 해결방법은 조금 뒤에 알아보자

#### 4. message integrity: Digital signature

---

- 밥이 앨리스에게 보낸 메세지를 트루디가 악의적으로 수정할 수 있는데 이를 해결하기 위해 밥은 메세지를 보내기 전 자신의 개인키로 signing 해서 보낸다.
- 이러한 서명 과정을 추가하면 중간에 트루디가 밥의 공개키로 데이터를 복호화한 후 수정해도 다시 재암호화가 불가능하기 때문에 안전하게 메세지를 보낼 수 있다.

---

> 송신자가 자신의 개인키로 암호화 해서 메세지를 보내는것 : signing, 자신임을 증명하기 위한 사인.

> 송신자가 상대방의 공개키로 암호화 해서 메세지를 보내는것 : encryption, 일반적인 암호화의 목적, 상대방만이 데이터를 열람할 수 있게하기 위함.

---

- 하지만 앞서 배웠듯 이러한 공개키 기법은 데이터가 커질수록 연산속도가 느려진다.
- 따라서 전체 메세지를 특정 해시를 통과시켜 가볍게 만든 후 해당 데이터를 signing 해서 연산시간을 줄일 수 있다.

- 이러한 digital signature는 인증과 무결성 두가지 기능을 제공한다.

#### 5. 인증 기관

---

- 잠시 앞으로 다시 되돌아가서 authentication 부분을 보자.
- authentication 에서 밥이 사인된 데이터를 복호화하기 위해서 받은 공개키가 진짜 앨리스가 맞는지 확인할 방법이 없다고 언급했다.
- 이러한 문제를 해결하기 위해서 인증기관이 등장한다.
- 평소 앨리스의 공개키는 100퍼센트 신뢰할 수 있는 인증기관이 인증기관의 개인키로 사이닝해서 가지고있다.
- 따라서 밥은 앨리스가 사인한 데이터와 함께 인증기관의 사인이 적용된 앨리스의 정보를 함께 요구하여

1. 인증기관의 공개키로 앨리스의 공개키를 얻음으로써 앨리스의 공개키임을 확신할 수 있다
2. 앨리스의 공개키로 앨리스의 메세지를 복호화 함으로써 상대방이 앨리스임을 확인할 수 있다의 결과를 얻을 수 있는것이다.

- 지금까지 애플리케이션 계층에서 사용되는 여러 보안기법에 대해서 공부했다.
