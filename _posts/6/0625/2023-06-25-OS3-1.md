---
title: "운영체제 3-1: Process"

categories:
  - OS
tags:
  - OS
---

> 이 글은 KOCW에서 제공하는 이화여자대학교 반효경 교수님의 운영체제 강의를 기반으로 내용을 정리하고 복습하기 위한 용도로 작성되었습니다.

## Process

> 프로세스의 개념, 프로세스의 상태(Process State), 프로세스의 개념, 프로세스 상태도, Process Control Block(PCB), 문맥교환(Context Switch), 프로세스를 스케줄링하기 위한 큐, Ready Queue와 다양한 Device Queue, 스케줄러(Scheduler)

#### 1. 프로세스란?

---

- 프로세스: 실행중인 프로그램을 프로세스라고 한다.
- 프로세스의 문맥(context): 개념적으로는 '프로세스가 얼마나 진행되었는지에 대한 상태를 알기위한 요소들'로 이해하면 된다
- 프로세스는 독자적인 주소공간(code, data, stack)을 가지고 cpu에서 실행되며 프로세스의 현재 상태를 나태내기 위한 여러 요소가 존재한다.

1. cpu의 수행상태를 나타내는 하드웨어 문맥: 프로세스는 cpu에서 실행되기 때문에 '어디까지 실행되었는가'에 대한 상태가 필요하다. 해당 상태에 대한 정보는 평소엔 cpu의 레지스터들에 담겨있다가 문맥 교환에 의해 PCB라는 자료구조에 저장된다.
2. 메모리와 관련된 프로세스의 주소 공간: 프로세스의 code, data, stack영역에 어떤 데이터들이 담겨있는가에 대한 정보들이다.
3. 프로세스 관련 커널 자료구조 (PCB, Kernel stack): 프로세스는 운영체제에 의해서 cpu자원을 할당받아 실행되고 관리되기 때문에 프로그램 실행과 동시에 커널의 PCB자료구조에 들어간다. 또한 프로세스가 시스템 콜 등 커널의 도움이 필요한 함수를 호출하면 커널의 stack영역에 해당 프로세스가 쌓인다. 이러한 커널 주소공간 에서의 상태 또한 프로세스의 상태 요소 중 하나이다.

- 위와같이 cpu, 메모리, 운영체제에서의 프로세스의 상태인 context를 알 수 있다면 현재 프로세스가 어떤상태인지 정확히 알 수 있다.
- 현대의 프로세스는 시분할방식으로 여러 프로세스의 작업이 cpu에서 번갈아가며 수행된다.
- 따라서 프로세스의 context를 저장해두지 않으면 자신의 다음 작업 순서가 왔을때
  프로세스를 이어서 수행할 수 없는 상황이 벌어지기 때문에 context가 필요한 것이다.

#### 2. 프로세스의 상태

---

- 지금까지 살펴봤던 프로세스의 동작에는 각각의 상태(state)가 정의되어있다.

프로세스의 상태도
![2-1](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/6210489b-c250-4b1a-a3d3-02ee486ab483)

1. Running: cpu를 잡고 instruction을 수행중인 상태
2. Ready: 물리적인 메모리에 프로세스가 올라와있어 당장 cpu의 작업을 기다리는 상태
3. Blocked(wait, sleep): cpu를 줘도 instruction을 수행할 수 없는 상태. ex, io작업을 수행중인 프로세스

> New: 프로세스가 생성중인 상태  
> Terminated: 프로세스가 수행이 끝난 상태 (정리과정이 남은 상태)

- 프로세스 실행에 따른 상태도는 다음과 같다.
  ![2-2](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/e9c2ce77-783c-4723-b195-6a9399636a81)

#### 3. PCB (Process Control Block)

---

![2-3](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/c220e6ac-e4e0-4b48-b408-fa161fddfa04)

- 바로 위의 프로세스 상태도의 queue 자료구조는 사실 cpu나 io디바이스마다 존재하는게 아닌 운영체제가 가지고있으며 관리하는 자료구조이다.
- cpu접근순서, io디바이스 작업순서 등등 모든 프로세스들의 실행을 관리하는것이 운영체제이며 이때 PCB자료구조가 사용된다.

![2-4](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/92a4bff2-f64d-457d-98e7-2b2b6ad34398)

- PCB: 운영체제가 각 프로세스를 관리하기 위해 프로세스 당 유지하는 정보로 오른쪽 표와같은 구조를 가지며 크게 4가지 구성요소가 있다. (4가지 구조체의 형태)
- 프로세스 하나당 하나의 PCB를 가진다.

1. OS가 관리상 사용하는 정보: 프로세스의 상태와 ID, 스케줄링 정보와 우선순위 등의 정보.
2. cpu 수행 관련 하드웨어 값: 프로세스의 문맥(context)를 표시하기 위한 정보들. cpu레지스터에 어떤 정보들이 적혀있었는지가 기록되어있다.
3. 메모리 관련: 프로세스의 code, data, stack이 메모리의 어떤 위치에 있는지에 대한 정보
4. 파일관련: 프로세스가 사용하는 리소스정보

#### 4. 문맥 교환 (Context switch)

---

- cpu는 여러작업을 번갈아가며 수행하는데 이때 cpu가 한 프로세스에서 다음 프로세스로 넘어가는것을 context switching이라고 한다.
- cpu가 어떤 프로세스에서 다른 프로세스로 넘어갈때 현재 작업중이던 cpu레지스터의 정보들과 PC의 값, 메모리 주소정보에 대한 문맥(context)들을 각 프로세스의 PCB에 저장해둔다.
- PCB는 커널의 data영역에 프로세스별로 저장된다.
- 다음 cpu제어권이 돌아와 context switching을 할때 이러한 PCB정보를 참고하여 작업을 이어서 진행할 수 있다.

![2-6](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/6e5e512d-dd41-4968-9763-fb545328406c)

- 첫번째 경우처럼 프로세스가 시스템콜(interrupt)를 요청하여 OS에게 cpu제어권을 넘겨준 경우에는 다시 프로세스에게 제어권이 복귀하므로 문맥교환이 일어나지 않는다.
- 그러나 hardware interrupt나 timer interrupt가 걸린 경우에는 OS가 다음 프로세스에게 제어권을 넘겨주므로 문맥교환이 일어난다.

#### 5. 프로세스를 스케줄링 하기 위한 큐들

---

1. Ready queue: 메모리 내에서 cpu제어권을 기다리는 프로세스의 큐
2. Device queue: io디바이스의 작업을 기다리는 큐
3. Job Queue: 모든 프로세스에 대한 큐

#### 6. 스케줄러 (scheduler)

---

1. Short-term Scheduler(CPU Scheduler, 단기 스케줄러)
   어떤 프로세스를 다음번에 Runnig 시킬지를 결정하는 스케줄러, 굉장히 빠른 단위의 시간에 이루어져야 한다.

2. Long-term scheduler(job Scheduler, 장기 스케줄러)
   프로세스가 시작되고 메모리(및 각종 자원)를 할당받는 순서를 정해주는 스케줄러.
   ready queue에 올라갈 프로세스를 정하는 과정이다.
   MultiPrograming(메모리에 얼마나 많은 프로세스를 올려놓을지)를 제어하는 역할을 한다.
   보통 시분할 시스템에는 장기 스케줄러가 없이 무조건 ready상태로 올라간다(모든 프로세스가 시작하면 메모리에 올라감)

3. Medium-Term Scheduler(swapper, 중기 스케줄러)
   프로세스에게서 메모리를 빼았는 역할을 한다.
   시분할 시스템에서는 장기 스케줄러가 없어 모든 프로세스가 시작되면 일단 메모리에 올라간다.
   이때문에 낭비되는 메모리가 존재하고 여유공간이 부족한 경우가 생기는데 이때 일부 프로세스를 통째로 메모리에서 디스크로 쫓아내는 역할을 하는 스케줄러다.
   시분할 시스템에서의 multiprograming을 제어한다.

- 원래 장기스케줄러만 존재할때는 애초부터 메모리에 올라갈 프로세스의 개수를 제어했지만 현재의 시스템은 장기 스케줄러없이 일단 메모리에 프로세스를 다 올려놓고 메모리에 여유공간이 없으면 중기 스케줄러가 몇몇 프로세스를 디스크로 쫓아내는 방식으로 작동한다.

- 이러한 중기스케줄러의 등장으로 프로세스의 상태가 하나 추가된다.

#### 7. Suspended(stoped)

---

- 외부적인 이유로 프로세스의 수행이 정지된 상태.
- 프로세스가 중기 스케줄러에 의해 통째로 디스크에 swap out된 상태를 가르킨다

- Blocked: 자신이 요청한 event가 만족되면 Ready상태로 되돌아감
- Suspended: 외부에서 resume해주어야 다시 메모리로 올라가 다른 상태로 돌아갈 수 있음

- 중기 스케줄러이외에도 다양한 외부적인 요인으로 프로세스가 Suspended상태로 들어갈 수 있다.

#### 8. Suspended가 추가된 프로세스의 상태도

---

![2-7](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/0e217459-9fb9-48a8-b655-bf28f8ab6cff)

- 프로세스가 cpu를 통해 본인의 코드를 실행중일때는 user mode Runing이다.
- 이때 시스템콜을 호출하여 cpu제어권이 OS에게 넘어갈때 프로세스가 blocked가 되고 OS가 running된다는 표현은 사용하지 않는다.
- 이때는 프로세스가 moniter모드로 running중이라고 표현한다.

- 또한 blocked 상태일때와 ready상태일때 suspended상태가 되었을때가 나누어져 있다.
