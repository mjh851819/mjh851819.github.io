---
title: "BOJ 2228 구간 나누기 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 2228 구간 나누기 C++

### 문제

N(1 ≤ N ≤ 100)개의 수로 이루어진 1차원 배열이 있다. 이 배열에서 M(1 ≤ M ≤ ⌈(N/2)⌉)개의 구간을 선택해서, 구간에 속한 수들의 총 합이 최대가 되도록 하려 한다. 단, 다음의 조건들이 만족되어야 한다.

1. 각 구간은 한 개 이상의 연속된 수들로 이루어진다.
2. 서로 다른 두 구간끼리 겹쳐있거나 인접해 있어서는 안 된다.
3. 정확히 M개의 구간이 있어야 한다. M개 미만이어서는 안 된다.

N개의 수들이 주어졌을 때, 답을 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 두 정수 N, M이 주어진다. 다음 N개의 줄에는 배열을 이루는 수들이 차례로 주어진다. 배열을 이루는 수들은 -32768 이상 32767 이하의 정수이다.

### 출력

첫째 줄에 구간에 속한 수들의 총 합의 최댓값을 출력한다.

---

### _풀이_

**다이나믹 프로그래밍, 메모제이션**

해당 문제는 [완전탐색 -> 시간 초과 -> 시간 초과가 나는 부분을 메모제이션으로 처리]의 방식으로 해결했다.

우선 완전탐색으로는 모든 구간에 대해서 탐색을 실행하며 특정 구간을 골랐다면 인덱스의 +2 칸부터 다음 구간을 탐색하는 재귀함수로 모든 구간을 탐색했다.

하지만 이런 완전탐색법으로는 중복된 칸을 다시 계산하기 때문에 시간초과가 발생하는데, 이때 메모제이션을 활용한다.

dp테이블의 의미는 아래와 같다.

**dp[st][cnt] = n : st부터 시작하는 배열에서 cnt개의 구간들을 생성했을때 총 합 중 최대값은 n이다.**

dfs 함수 자체가 구간합 중 최댓값을 return하면서 구간의 시작점과 구간의 갯수를 인자로 받기 때문에 함수의 연산이 끝날때마다 해당 값을 저장해주면 다음에 똑같은 함수가 호출되었을때 중복 계산을 막을 수 있다.

```c++

int n, m;
int arr[105];
int dp[105][105];
int vis[105][105];
const int mini = -32768 * 100;

int dfs(int cnt, int st) {
    
    if (vis[st][cnt] != 0) return dp[st][cnt];

    int maxi = mini;
    for (int i = st; i < n; i++) {
        int sc = 0;
        for (int j = i; j < n; j++) {
            sc += arr[j];
            if(cnt < m) maxi = max(maxi, sc + dfs(cnt + 1, j + 2));
            else maxi = max(maxi, sc);
        }
    }
    
    dp[st][cnt] = maxi;
    vis[st][cnt] = 1;
    return maxi;
}

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m;
    memset(dp, mini, sizeof(dp));
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    
    cout << dfs(1, 0);
    
}

```
