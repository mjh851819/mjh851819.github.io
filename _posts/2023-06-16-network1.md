---
title: "네트워크 3-4 전송 계층: TCP의 congestion control"

categories:
  - Network
tags:
  - Network
---

> 이 글은 KOCW에서 제공하는 한양대학교 이석복 교수님의 컴퓨터 네트워크 강의를 기반으로 내용을 정리하고 복습하기 위한 용도로 작성되었습니다.

## Congestion Control

> 앞서 flow control로 window size를 조절하는 방법을 알아봤다. 그렇다면 네트워크 상황을 고려하여 window size를 조절하는 congestion control은 어떻게 이루어질까?

##### 1. congestion control이란?

---

- congestion의 정의: 너무 많은양의 데이터를 한번에 보내서 네트워크 속도에 문제가 생기는 것 -> 패킷 유실, 딜레이 발생으로 이어짐.
- 통신 과정에서 network 컨디션이 실시간으로 얼마나 혼잡한지 알수있는 방법이 없다.
- flow control의 리시브 버퍼와 다르게 직관적으로 조절할 수 있는 지표가 없다.
- 따라서 우리는 network 상황을 짐작을 할 수밖에 없다.

##### 2. Congestion Control Toy example

---

- **시나리오 1**
  ![4-1](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/7f02c0cd-4eff-4186-aeba-bd1b63d79419)

- 데이터를 전송하는 sender A,B와 receiver C, D, 하나의 라우터가 있는 상황을 가정하자. 라우터의 용량은 R이고 재전송이 일어나지 않는 환경이다.
- A와 B의 데이터 전송 속도를 D(in) 이라고 표시하고 C, D가 받아들이는 데이터의 양을 D(out)이라 표시하자.
- D(in)을 무한히 증가시키면 A와 B는 R용량을 라우터를 통해서 데이터를 전달하므로 D(out)은 R/2에서 더이상 증가하지 않는다. (첫번째 그래프)
- 이때 D(in)이 R/2에 가까워질수록 Delay는 무한히 증가하면서 피해가 발생한다. (두번째 그래프)

---

- **시나리오 2**
  ![4-2](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/7d094329-14ee-40e3-9fb8-bef909ed04b4)
- 시나리오 2는 시나리오 1에서 라우터에 좀 더 현실적으로 제한된 큐사이즈(R)를 두고 sender는 timeout이 되면 재전송을 한다.
- 또한 D(in)은 전송계층에서 재전송 해야할 데이터의 양까지 더해진 값이다.
- 이상적인 가정으로 sender는 C,D의 버퍼에 공간이 있을때만 데이터를 보낸다.

- A에서 데이터를 보낼때 라우터의 문제로 패킷 로스가 일어나면 A는 재전송 데이터를 보낸다.
- 이때 발생하는 현상을 자세히 관찰해보자.
- 시나리오1 에서 A와 B는 라우터의 용량이 R이므로 최대 R/2의 속도로 데이터를 전송할 수 있었다.
- 그러나 패킷 로스로 인해 재전송이 발생하면서 R/2에 오리지널 데이터 뿐만 아니라 재전송 데이터까지 포함되면서 C,D가 받는 오리지널 데이터는 R/2에서 R/2 - a로 줄어들게 된다.
- 즉 C,D의 입장에서 실제로 받아들이는 데이터의 양(D(out))은 줄어드는것이다.

> congestion이 발생하면 큐잉 딜레이가 길어지고, timeout이 발생할 확률이 늘어난다. 그에 따라 재전송량도 많아지면서 congestion이 더욱 증가하는
> 악순환이 일어나는것이다.

---

- **시나리오 3**
  ![4-3](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/51c73e9a-8035-48ad-84f1-eafa3cdc7e10)

- 더욱 현실적으로 들어가서 데이터가 전송될 때 거치는 라우터가 여러개라고 가정해보자.
- 모든 라우터가 혼잡하고 A가 C에게 데이터를 전송할때 C까지 도달하기 전 마지막 라우터에서 데이터가 Loss되었을때 상황을 살펴보자.
- A의 데이터는 이전까지의 라우터의 자원들을 사용하여 마지막 라우터까지 도달했고 그 과정에서 몇몇 다른 데이터들은 Loss되었을것이다.
- 하지만 C에 도달하지 못하고 Loss되었다면 이전 upstream까지 소모된 자원들 모두를 손해보는것이다.
- Congestion으로 인해 단순히 마지막에 Loss된 데이터 뿐만 아니라 연쇄적인 손해가 발생했다.

---

- **결론**

- 지금까지 배운 Tcp의 데이터전송 과정은 timeout이 발생하면 데이터를 재전송한다. - 애플리케이션에서 2KB의 데이터를 받았을때 timeout이 일어나면 tcp는 reliable을 지키기 위해 계속해서 재전송을 하여 2,4,6... 점점 많은데이터를 재전송하고 이는 congestion을 계속해서 악화시킨다.
- 이러한 이유로 congestion control을 통해서 네트워크 상황을 파악하고 데이터 전송량을 조절해야 하는것이다.
  > _그렇다면 네트워크 상황을 어떻게 파악할 수 있을까?_

##### 3. tcp에서 네트워크 상황을 파악하는 방법

---

> 생각해 볼 수 있는 수단은 두가지다.

1. 라우터에서 직접 네트워크 상황을 전달받는다.
2. tcp 통신을 하는 두 포인트간 정보를 주고받으며 네트워크 상황을 파악한다.

- 라우터는 데이터 전송으로 하는일이 많기때문에 2번으로 네트워크 상황을 파악한다.
- 간단하게 설명하면 세그먼트를 보내고 ACKs가 왔다면 네트워크 상황이 괜찮다고 판단한다.
- timeout이 왔다면 네트워크에 문제가 있다. 라는 식으로 서로의 피드백을 통해서 네트워크 상황을 유추한다.

##### 4. 디테일한 congestion control

---

**- additive increase multiplicative decrease (+ 적 증가, \* 적 감소)**
![4-4](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/ab787ba4-61ca-449f-8500-163ca3fda28f)

- 만약 10의 데이터를 보냈을때 정상적인 ACKs가 왔다면 데이터를 더 빠른 속도로 보내도 된다는 의미다. 이때 증가량을 additive하게 점진적으로 11, 12, 13... 의 식으로 증가시킨다.
- 이후 timeout이 발생하면 이미 네트워크가 상당히 혼잡하다는 의미이므로 속도를 크게 줄일필요가 있다.
- 이때 multiplicative하게 20 > 10 처럼 전송속도를 조절하는것이다.
- 이러한 과정을 계속해서 반복하는것이 tcp의 **congestion control**이고 데이터 전송속도의 최댓값을 아주 조심스럽게 찾는 과정이다.

##### 5. Receiver의 송신 데이터량

---

> 최종적으로 tcp에서 sending data의 rate를 알아보자.

- congestion을 고려한 window size를 congWin이라고 하자.
- sender는 한번에 congWin만큼의 데이터를 보내고 RTT이후 ACKs를 받았을때 다시 congWin만큼의 데이터를 보내는것이 허락된다.
- 즉 rate = congWin/RTT (Byte/sec)의 값을 가지는 것이고 이러한 congWin값은 네트워크 상황에따라 유동적이므로 rate값은 계속해서 변화한다.
- 우리가 파일 전송/다운로드에 속도가 오르락 내리락하는 이유가 바로 이 때문이다.

##### 6. congestion control 초기과정

---

> congWin의 값을 얼마로 두고 전송을 시작해야할까?

- 초기 전송량을 너무 크게두고 전송을 시작하면 네트워크가 그 즉시 혼잡해지므로 위험하다. 따라서 함부로 데이터를 막 보낼 수는 없다.
- 즉 개념적인 의미로 '세그먼트 하나만 보내면서 시작한다' 이를 slow start라고 표현한다. - 이후 정상적인 ACK를 받을때마다 전송량을 증가시키는 방식이다.
- 이때 Threshold라는 값이 설정되어있고 전송속도가 Threshold에 도달하기 전까지는 큰 보폭으로 전송속도가 증가한다.
- 전송속도가 Threshold에 도달하면 이후 congestion이 발생할 위험이 있으므로 linearly하게 전송속도를 증가시킨다.
  > 이후 loss가 발생했다면 과정이 조금 더 복잡해진다.

##### 7. congestion control에서 패킷로스를 판단하는 과정

---

- tcp에서 패킷이 유실되었다고 판단하는 근거는 두가지다. 1. 3duplicate Acks / 2. Timeout 둘 중 하나다.
- 이때 congestion control의 입장에서 두가지 사건은 큰차이가 있다.
- 3duplicate Acks의 경우는 여러개의 데이터를 보냈을때 중간 데이터만 어쩌다 loss가 일어났다는 뜻이다.
- 반면 Timeout이 발생했다는것은 전송 과정에서 네트워크에 큰 부하가 생겼다고 확신할 수 있는 근거다.
- 즉 3duplicate Acks와 Timeout에 의한 loss에 따른 congestion control의 대처수준은 다르다.

![4-5](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/d1416648-60db-4b1f-ad80-ec90b88a1df1)

- 초기의 tcp [tao]는 loss가 일어나면 무조건 데이터 전송을 slow start부터 다시시작하고 threshold값을 congestion이 일어난 절반의 값으로 줄였다.
- 즉 _timeout과 3d Acks의 구분없이 똑같이 전송량을 크게 감소시켰다._
- 이후의 개선된 TCP [Reno]라는 시리즈는 이를 구분하여 만약 3d Acks로 인해 로스가 발생하면 초기값을 slow start가 아닌 감소한 threshold값부터 linearly하게 증가하는 방향으로 설계되었다.
- 좀 더 지능적인 대응을 할 수 있다는 것이다.

##### 6. Why TCP is fair?

---

> 우리가 지금까지 배운 내용에서는 두 tcp연결이 하나의 라우터를 쓸때 라우터 용량의 정확히 절반씩 나누어 쓴다고 설명했다. 이러한 가정은 현실에서도 비슷하게 일어나는데 그 이유가 뭘까?

![4-6](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/e9c51c27-7c8c-4db0-8e8a-583b049881e0)

- 시작은 두 커넥션이 공평하지 않게 라우터의 용량을 쓸지 몰라도 congestion이 터졌을때 감소되는 전송속도는 차이가 있다.
- 따라서 큰 속도로 보내던 연결은 큰폭으로 속도가 줄어들고 적은 속도로 보내던 연결은 비교적 적은 속도가 줄어듦을 반복하면서 결과적으로는 라우터의 R/2만큼의 용량을 공평하게 나누어 가지는 상황이 벌어지는것이다.
  > 그러나 udp의 개입이나 머신별 커넥션의 갯수에 따라서 상황은 변할 수 있다.
