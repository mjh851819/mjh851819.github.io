---
title: "BOJ 17609 회문 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 17609 회문 C++

문제

> 회문(回文) 또는 팰린드롬(palindrome)은 앞 뒤 방향으로 볼 때 같은 순서의 문자로 구성된 문자열을 말한다. 예를 들어 ‘abba’ ‘kayak’, ‘reviver’, ‘madam’은 모두 회문이다. 만일 그 자체는 회문이 아니지만 한 문자를 삭제하여 회문으로 만들 수 있는 문자열이라면 우리는 이런 문자열을 “유사회문”(pseudo palindrome)이라고 부른다. 예를 들어 ‘summuus’는 5번째나 혹은 6번째 문자 ‘u’를 제거하여 ‘summus’인 회문이 되므로 유사회문이다.

> 여러분은 제시된 문자열을 분석하여 그것이 그 자체로 회문인지, 또는 한 문자를 삭제하면 회문이 되는 “유사회문”인지, 아니면 회문이나 유사회문도 아닌 일반 문자열인지를 판단해야 한다. 만일 문자열 그 자체로 회문이면 0, 유사회문이면 1, 그 외는 2를 출력해야 한다.

입력

> 입력의 첫 줄에는 주어지는 문자열의 개수를 나타내는 정수 T(1 ≤ T ≤ 30)가 주어진다. 다음 줄부터 T개의 줄에 걸쳐 한 줄에 하나의 문자열이 입력으로 주어진다. 주어지는 문자열의 길이는 3 이상 100,000 이하이고, 영문 알파벳 소문자로만 이루어져 있다.

출력

> 각 문자열이 회문인지, 유사 회문인지, 둘 모두 해당되지 않는지를 판단하여 회문이면 0, 유사 회문이면 1, 둘 모두 아니면 2를 순서대로 한 줄에 하나씩 출력한다.

---

_풀이_

투포인터와 백트래킹을 조합해서 풀 수 있는 문제였다.

유사 회문이 아닌 회문을 구하는 방법은 다음과 같다

1. 문자열s의 시작점을 st, 마지막을 en으로 두고 탐색을 시작한다.
2. s[st]와 s[en]을 st >= en까지 계속해서 비교한다.
3. 무사히 끝까지 비교하게 된다면 해당 문자열은 회문이다.

유사까지 고려하기 위해선 다음과정이 추가된다.

1. 위의 2번 과정에서 만약 s[st]와 s[en]의 값이 다르다면
2. s[st + 1]과 s[en]이 같다면 이어서 정상 흐름으로 진행한다.
3. s[st]와 s[en - 1]이 같다면 이 또한 정상 흐름으로 진행한다.
4. 2번 3번 모두 해당하지 않거나 이미 이전 백트레킹 과정에서 2번이나 3번 과정을 거쳤다면 해당 문자열은 회문이 아니다.
5. st >= en의 경우까지 무사히 도착하면 2,3번 과정을 거쳤다면 유사회문, 거치지 않았다면 회문으로 판단한다.

```c++

int t;
string s;
int flag;

void check(int st, int en, int cnt) {
    if (st >= en) {
        if (cnt == 1) flag = 0;
        else flag = 1;
        return;
    }
    if (s[st] == s[en]) {
        check(st + 1, en - 1, cnt);
    }
    else {
        if (cnt == 0) return;
        if (s[st] == s[en - 1]) {
            check(st, en - 1, 0);
        }
        if (s[st + 1] == s[en]) {
            check(st + 1, en, 0);
        }
        else {
            return;
        }
    }
}

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> t;
    while (t--) {
        cin >> s;
        flag = 2;
        check(0, s.size() - 1, 1);
        cout << flag << '\n';
    }
}

```
