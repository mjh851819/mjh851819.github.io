---
title: "운영체제 3-3: Process Management 1"

categories:
  - OS
tags:
  - OS
---

> 이 글은 KOCW에서 제공하는 이화여자대학교 반효경 교수님의 운영체제 강의를 기반으로 내용을 정리하고 복습하기 위한 용도로 작성되었습니다.

## Process Management 1

> 프로세스 생성(Process Creation), 프로세스 종료(Process Termination), 프로세스 생성(Process Creation), 프로세스와 관련한 시스템콜, 프로세스 간 협력, Message Passing, Interprocess communication

#### 1. 프로세스 생성

---

- 프로세스의 생성은 부모 프로세스가 자식 프로세스를 생성하는 구조다.
- 자식 프로세스는 주로 복제 생성으로 이루어지며 부모-자식 형태의 트리 구조를 형성한다.
- 자원의 공유: 부모와 자식이 프로세스 자원을 공유할수도, 자원을 두고 경쟁할 수도 있다. (원칙적으로는 공유하지 않음)
- 수행: 부모와 자식이 공존하여 실행되는 모델과, 부모가 자식의 수행을 기다리는(waiting) 모델이 있다.

#### 2. 자식 프로세스의 주소 공간 (Address space)

---

- 자식 프로세스는 보통 부모 프로세스가 복제의 형태로 생성한다.
- 자식 프로세스는 부모의 주소공간(binary AND OS data)을 복제한 후 그 위에 새로운 프로그램을 올림으로써 자신의 주소공간을 가진다.
- 위 과정에서 부모의 주소공간을 복제하는것을 시스템 콜 fork()라 하며 이후 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올린다.
  > fork() 와 exec()모두 시스템 콜 이기 때문에 사용자가 임의로 프로세스를 생성하는것이 아닌 운영체제의 도움을 받아서 프로세스를 생성한다.

#### 3. 프로세스 종료(exit, abort)

---

- 프로세스가 마지막 명령을 수행한 후 exit() 시스템콜을 통해서 운영체제에게 프로세스의 종료를 알린다.
- 프로세스가 종료됨으로써 부모에게 output data를 보내고 운영체제에게 각종 자원들이 반납된다.
- 부모 프로그램이 abort() 시스템 콜로 자식의 수행을 강제로 종료시킬 수 있다.
- 자식이 자원의 할당치를 넘어선 요구를 할때, 자식에게 할당된 태스크가 더이상 필요하지 않을때 2가지의 경우에 강제로 프로세스가 종료된다.
- 부모 프로세스가 종료되는 경우 자식이 더이상 수행되지 않도록 두지 않기 위해서 자식 프로세스부터 종료시킨다.

#### 4. 프로세스와 관련한 4가지 시스템 콜

---

![3-6](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/80afcc55-7499-4bd1-b46e-928f7461d506)

#### 5. fork()

---

![3-3](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/41654cb2-ace5-4f2f-b1a5-9bdbaf6f4273)

- 위 그림은 부모 프로세스(왼쪽 코드)가 fork() 시스템 콜을 통해서 자식 프로세스(오른쪽 코드)를 생성(복제)한 예시이다.
- 이때 자식 프로세스는 fork()이후의 시점부터 실행하도록 설계되어 있는데, 부모 프로세스에서 복제되는 과정에서 복제된 PC값을 참고하여 자식이 어느부분부터 실행해야 할지 알고있기 때문이다.
- 이때 fork를 통해서 복제된 자식과 부모프로세스를 서로 구분하기 위해 위와 같이 pid값이 사용되는데 자식은 pid값으로 0을 부여받고 부모는 자식의 pid값을 받기 때문에 양수의 pid를 가진다.
- 이렇듯 fork()의 return value가 다름을 이용해서 자식프로세스와 부모프로세스가 각각 다른 일을 할 수 있도록 설계할 수 있다.

#### 6. exec()

---

![3-4](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/9db8df34-5850-479b-a9b7-bd55ca9b03ac)

- fork()로 의해 복제된 자식프로세스에 새로운 프로세스를 덮어씌우기 위한 시스템 콜이다.
- 위 그림에서 자식프로세스가 생성되고 exec()시스템 콜에 의해 /bin/date에 해당하는 새로운 프로세스가 실행된다.
  > exec()는 꼭 fork()이후에 사용되는 시스템콜이 아니다. 다른 적절한 상황에서 프로그램을 덮어쓸 때 사용될 수 있다.
  > 한번 exec()하면 다시 원래대로 돌아올 수 없다.

#### 7. wait()

---

![3-5](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/bba3a991-7748-4f1f-8b88-9ab3e4987051)

- 프로세스를 blocked 상태로 만드는 시스템 콜
- 자식프로세스를 생성하고 wait() 시스템콜을 호출하면 자식 프로세스가 종료되어 리턴값이 올때까지 대기하게 만들 수 있다.

- 위 그림에서 부모프로세스가 자식을 복제한 후에 if문에 의하여 wait() 시스템콜이 호출된다.
- 그렇다면 부모는 자식의 수행이 끝날때까지 blocked 상태에 들어가고 자식 프로세스는 if문에 의하여 지정된 작업을 수행한다.

- wait() 시스템 콜을 이용해서 부모가 자식 프로세스의 종료를 기다리는 모델을 구현할 수 있다.

#### 8. exit()

---

- 프로세스를 종료시킬때 호출하는 시스템 콜

- 자발적 종료
  프로세스에 명시적으로 exit() 시스템콜이 호출된 경우
  명시적으로 exit()을 호출하지 않아도 main함수가 return되는 위치에서 자동으로 호출된다.
- 비 자발적 종료
  부모 프로세스가 자식 프로세스를 강제로 종료시킬때 호출한다.(자식 프로세스가 한계치를 넘는 자원을 요청, 더이상 자식의 태스크가 필요하지 않음)
  사용자가 kill 명령을 입력한 경우
  부모가 종료되는 경우 자식들이 먼저 종료된다.
  프로세스가 자발적으로 종료되지 못하고 외부요인에 의해서 종료된다.

#### 9. 프로세스 간 협력

---

- 독립적 프로세스(Independent Process): 프로세스는 각자의 주소공간을 가지고 있기에 기본적으로 프로세스는 독립적인 특성을 가지며 다른 프로세스의 수행에 영향을 미치지 못한다.
- 협력 프로세스(Cooperating Process): 필요에 따라 프로세스 협력 메커니즘을 통해 다른 프로세스의 수행에 영향을 미치는 프로세스

- 프로세스 간 협력 메커니즘 (IPC: Interprocess Communication): 프로세스 간 정보를 주고받을 수 있는 메커니즘, 크게 2가지 방법이 존재한다.

1. message passing (메시지를 주고받음)
2. shared memory (주소 공간 공유)

![3-8](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/7005e80e-9829-4aac-bb5d-669faa1cb917)

#### 10. message passing

---

- 두 프로세스가 서로 메세지를 주고받으면서 작업함으로써 서로에게 영향을 끼치는 방법.
- 프로세스는 독립적이기에 스스로 다른 프로세스에게 메세지를 보낼 수 없다.
- 따라서 커널을 통해서 다른 프로세스로 메세지를 전달한다.
- Message System: 프로세스 사이에 공유 변수를 사용하지 않고 통신하기 위한 시스템
  ![3-7](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/969371f4-0e03-4972-a394-34ede53e1856)

- 이러한 메세지를 전달하는 방법도 2가지로 나뉜다. (Direct Communication, Indirect Communication)
- direct Communication은 메세지를 받을 프로세스가 무엇인지 명시하여 직접적으로 보내는 방법이고 Indirect Communication은 mailbox나 port를 통해서 간접적으로 전달하는 방법이다.

#### 11. shared memory

---

- 원칙적으로 프로세스는 독립적인 주소공간을 가지지만 상호작용을 위해서 일부 주소공간을 프로세스끼리 공유하는 시스템이다.
- 두 프로세스가 메모리에 올라갈때 일정부분의 주소값을 같게 가짐으로써 같은 공간을 공유하는 효과를 낸다.
- 커널을 통해서 이러한 맵핑이 가능하다.
- 초기 공유 메모리를 할당받는 과정 이외에는 커널의 영향을 받지 않는다.
