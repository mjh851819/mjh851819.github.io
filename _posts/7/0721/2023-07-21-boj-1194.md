---
title: "BOJ 1194 달이 차오른다, 가자. C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 1194 달이 차오른다, 가자. C++

### 문제

지금 민식이가 계획한 여행은 달이 맨 처음 뜨기 시작할 때 부터, 준비했던 여행길이다. 하지만, 매번 달이 차오를 때마다 민식이는 어쩔 수 없는 현실의 벽 앞에서 다짐을 포기하고 말았다.

민식이는 매번 자신의 다짐을 말하려고 노력했지만, 말을 하면 아무도 못 알아들을 것만 같아서, 지레 겁먹고 벙어리가 되어버렸다. 결국 민식이는 모두 잠든 새벽 네시 반쯤 홀로 일어나, 창 밖에 떠있는 달을 보았다.

하루밖에 남지 않았다. 달은 내일이면 다 차오른다. 이번이 마지막기회다. 이걸 놓치면 영영 못간다.

영식이는 민식이가 오늘도 여태것처럼 그냥 잠 들어버려서 못 갈지도 모른다고 생각했다. 하지만 그러기엔 민식이의 눈에는 저기 뜬 달이 너무나 떨렸다.

민식이는 지금 미로 속에 있다. 미로는 직사각형 모양이고, 여행길을 떠나기 위해 미로를 탈출하려고 한다. 미로는 다음과 같이 구성되어져있다.

1. 빈 칸: 언제나 이동할 수 있다. ('.')
2. 벽: 절대 이동할 수 없다. ('#')
3. 열쇠: 언제나 이동할 수 있다. 이 곳에 처음 들어가면 열쇠를 집는다. ('a', 'b', 'c', 'd', 'e', 'f')
4. 문: 대응하는 열쇠가 있을 때만 이동할 수 있다. ('A', 'B', 'C', 'D', 'E', 'F')
5. 민식이의 현재 위치: 빈 곳이고, 민식이가 현재 서 있는 곳이다. ('0')
6. 출구: 달이 차오르기 때문에, 민식이가 가야하는 곳이다. 이 곳에 오면 미로를 탈출한다. ('1')

달이 차오르는 기회를 놓치지 않기 위해서, 미로를 탈출하려고 한다. 한 번의 움직임은 현재 위치에서 수평이나 수직으로 한 칸 이동하는 것이다.

민식이가 미로를 탈출하는데 걸리는 이동 횟수의 최솟값을 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 미로의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 50) 둘째 줄부터 N개의 줄에 미로의 모양이 주어진다. 같은 타입의 열쇠가 여러 개 있을 수 있고, 문도 마찬가지이다. 그리고, 문에 대응하는 열쇠가 없을 수도 있다. '0'은 한 개, '1'은 적어도 한 개 있다. 열쇠는 여러 번 사용할 수 있다.

### 출력

첫째 줄에 민식이가 미로를 탈출하는데 드는 이동 횟수의 최솟값을 출력한다. 만약 민식이가 미로를 탈출 할 수 없으면, -1을 출력한다.

---

### _풀이_

BFS와 비트마스킹을 통해서 해결할 수 있는 문제였다.

처음 풀어보는 비트마스킹 문제였다. 해당 문제에서 비트마스킹을 활용하는 방법은 다음과 같다.

a~f의 열쇠와 A~F의 문을 각각 6자리의 2진수에서 각 자리에 대응시킨다.

- a, A : 000001
- b, B : 000010
  ...
- f, F : 100000

초기 탐색을 시작할때 키값을 000000으로 시작하고 열쇠를 주울때마다 현재 키값과 열쇠에 해당하는 2진수를(shift 연산을 통해서 구한다) OR 연산을 통해 키값을 갱신하고 문을 만나면 AND 연산을 통해서 문을 통과할 수 있는지 체크한다.

이러한 과정을 수행하기 위해서는 같은 칸을 방문하는 vis 배열을 3차원으로 관리해 줘야 한다. 같은 칸을 방문하더라도 방문한 시점에서 소지한 키값이 다르면 거리를 따로 측정해줘야 하기 때문이다.

위와 같은 조건들을 지켜며 탐색하면서 가장 먼저 만나는 탈출구에서 해당 칸의 step을 출력하면 최단거리를 구할 수 있으며, q가 빌때까지 탈출구를 찾지 못하면 -1을 출력해야 한다.

```c++

int n, m;
char board[51][51];
int dist[51][51][65];
pair<int, int> st;

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        string s;
        cin >> s;
        for (int j = 0; j < m; j++) {
            board[i][j] = s[j];
            if (s[j] == '0') st = { i,j };
        }
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            fill(dist[i][j], dist[i][j] + 65, -1);
        }
    }

    queue<tuple<int, int, int, int>> q;
    q.push({ st.Y,st.X,0,0});
    dist[st.Y][st.X][0] = 0;

    while (!q.empty()) {
        int y, x, step, key;
        tie(y, x, step, key) = q.front(); q.pop();
        if (board[y][x] == '1') {
            cout << step;
            return 0;
        }
        for (int dir = 0; dir < 4; dir++) {
            int ny = y + dy[dir];
            int nx = x + dx[dir];
            if (nx < 0 || nx >= m || ny < 0 || ny >= n) continue;
            if (board[ny][nx] == '#' || dist[ny][nx][key] != -1) continue;
            if (board[ny][nx] == '1' || board[ny][nx] == '0' ||board[ny][nx] == '.') {
                q.push({ ny,nx,step + 1,key });
                dist[ny][nx][key] = step + 1;
            }
            else if (board[ny][nx] >= 'a' && board[ny][nx] <= 'f') {
                int a = (board[ny][nx] - 'a');
                int tmp = 1 << a;
                dist[ny][nx][key|tmp] = step + 1;
                q.push({ ny,nx,step + 1,key | tmp });

            }
            else if (board[ny][nx] >= 'A' && board[ny][nx] <= 'F') {
                int a = board[ny][nx] - 'A';
                int tmp = 1 << a;
                if (!(key & tmp)) continue;
                q.push({ ny,nx,step + 1,key });
                dist[ny][nx][key] = step + 1;
            }
        }
    }

    cout << -1;

}

```
