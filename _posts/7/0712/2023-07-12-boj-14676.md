---
title: "BOJ 14676 영우는 사기꾼? C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 14676 영우는 사기꾼? C++

문제

> 영선이와 영우는 최근 ‘우주전쟁’ 이라는 게임을 시작했다. ‘우주전쟁’은 1대1로 하는 RTS(실시간 전략 게임) 게임으로, 각 플레이어는 건물을 건설하고, 건물에서 유닛을 생성하여 싸운다. ‘우주전쟁’은 건물을 짓는 순서가 정해져 있는데, 예를 들어 건물들이 다음과 같은 관계도를 가진다고 할 때,

![1](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14676/1.png)

> 2, 3번 건물은 반드시 1번 건물이 건설된 상태여야 지어질 수 있고, 4번 건물은 반드시 2, 3번 건물이 건설된 상태여야 지어질 수 있다. 단 4번 건물은 1번 건물과는 직접적인 연관이 없기 때문에 1번 건물이 없다고 하더 라도 4번 건물은 건설이 가능하다. 이때 1번 건물은 2, 3번 건물에 영향을 미친다고 할 수 있고, 2, 3번 건물은 4번 건물에 영향을 미친다고 할 수 있다. 또한 모든 건물들은 중복 건설이 가능하다. ‘우주전쟁’ 게임의 제작사 인 ‘얼음폭풍’사는 게임의 밸런스를 유지하기 위해 한 건물은 최대 3개의 건물에게만 영향을 미치도록 하였다. 또 ‘우주전쟁’ 게임에는 치트키가 하나 있는데, 이 치트키를 사용하면 원하는 건물을 마음대로 설치할 수 있다. 하지만 이 치트키를 사용하면 너무나 쉽게 게임에서 이길 수 있기 때문에 영선이와 영우는 서로 치트키를 쓰지 않기로 약속했다. 하지만 이상하게도 영우는 영선이와의 게임에서 모두 승리하였고, 그런 영우를 이상하게 여긴 영선이는 영우의 건물 건설/파괴 정보를 가져왔다. (치트키로 건설한 건물은 건설 정보에 들어가지 않는 다.) 영우의 게임정보를 보고 영우가 치트키를 사용했는지 판단하는 프로그램을 만들어 영선이를 도와주자.

입력

> 프로그램의 입력은 표준 입력으로 받는다. 입력의 첫 줄에는 건물 종류의 개수 N, 건물 사이 관계의 개수 M, 영우의 게임 정보의 개수 K가 주어진다.(1 ≤ N, M, K ≤ 100,000) 다음 줄부터 M줄에 걸쳐 건물의 관계인 X Y 가 차례대로 중복 없이 주어진다. (X를 건설해야 Y를 건설할 수 있음.) (1 ≤ X, Y ≤ N) 다음 줄부터 K줄에 걸쳐 영우의 게임 정보가 다음과 같이 주어진다. (1 ≤ a ≤ N)

- 1 a(영우가 a번 건물을 1개 건설함)
- 2 a(영우의 a번 건물이 1개 파괴됨)

출력

> 프로그램의 출력은 표준 출력으로 한다. 영우가 정상적으로 건물을 건설하거나, 건설한 만큼의 건물만 파괴되 었다면 ‘King-God-Emperor’를. 건설할 수 없는 건물을 건설하거나, 건설한적 없는 건물이 파괴되었다면 ‘Lier!’ 를 출력하자.

---

_풀이_

위상정렬의 개념을 사용해서 해결할 수 있는 문제였으나, 처음보는 유형의 위상정렬 문제였다.

풀이 과정은 아래와 같다.

1. 기존의 위상정렬 문제처럼 처음부터 정렬을 하지 않고 노드와 간선간의 차수만 표시해 둔다.
2. 각 건물의 건설명령이 들어왔을때 해당 건물의 차수가 0인지 확인한다.
   건물의 차수가 0이라면 건설 가능한 상태이므로 건물을 건설한다.
   차수가 0이 아니라면 선행 건물들이 지어진 상태가 아니므로 Lier를 출력하고 종료한다.
3. 만약 건물을 건설할 수 있다면 chk[]배열로 건설된 건물의 갯수를 관리하는데, 중복된 건설이 아닐 경우에만 영향을 미치는 건물들의 차수를 줄여준다.
4. 건물의 파괴 명령이 들어왔을때 현재 지어진 해당 건물의 갯수를 확인하여 지어져 있지 않은 건물을 파괴하는 명령일 시 Lier를 출력하고 종료한다.
5. 건물을 파괴한 후 남아있는 건물이 없다면 영향을 미치는 건물들의 차수를 1 증가시킨다.

위와같이 위상정렬의 차수 개념을 적용하여 문제를 해결할 수 있다.

```c++

int n, m, k;
int dg[100005];
int chk[100005];
vector<int> adj[100005];

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m >> k;
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        dg[v]++;
        adj[u].push_back(v);
    }

    for (int i = 0; i < k; i++) {
        int op, num;
        cin >> op >> num;
        if (op == 1) {
            if (dg[num] != 0) {
                cout << "Lier!";
                return 0;
            }
            if (chk[num] == 0) {
                for (auto nxt : adj[num]) {
                    dg[nxt]--;
                }
            }
            chk[num]++;
        }
        if (op == 2) {
            if (chk[num] < 1) {
                cout << "Lier!";
                return 0;
            }
            chk[num]--;
            if (chk[num] == 0) {
                for (auto nxt : adj[num]) {
                    dg[nxt]++;
                }
            }
        }
    }

    cout << "King-God-Emperor";

}

```
