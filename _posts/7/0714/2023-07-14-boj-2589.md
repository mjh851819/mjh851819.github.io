---
title: "BOJ 2589 보물섬 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 2589 보물섬 C++

문제

> 보물섬 지도를 발견한 후크 선장은 보물을 찾아나섰다. 보물섬 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 각 칸은 육지(L)나 바다(W)로 표시되어 있다. 이 지도에서 이동은 상하좌우로 이웃한 육지로만 가능하며, 한 칸 이동하는데 한 시간이 걸린다. 보물은 서로 간에 최단 거리로 이동하는데 있어 가장 긴 시간이 걸리는 육지 두 곳에 나뉘어 묻혀있다. 육지를 나타내는 두 곳 사이를 최단 거리로 이동하려면 같은 곳을 두 번 이상 지나가거나, 멀리 돌아가서는 안 된다.

> 보물 지도가 주어질 때, 보물이 묻혀 있는 두 곳 간의 최단 거리로 이동하는 시간을 구하는 프로그램을 작성하시오.

입력

> 첫째 줄에는 보물 지도의 세로의 크기와 가로의 크기가 빈칸을 사이에 두고 주어진다. 이어 L과 W로 표시된 보물 지도가 아래의 예와 같이 주어지며, 각 문자 사이에는 빈 칸이 없다. 보물 지도의 가로, 세로의 크기는 각각 50이하이다.

출력

> 첫째 줄에 보물이 묻혀 있는 두 곳 사이를 최단 거리로 이동하는 시간을 출력한다.

---

_풀이_

BFS와 완전탐색으로 해결할 수 있는 문제였다.

육지에 해당하는 모든 좌표에 대해서 BFS를 실행하면서 가장 이동거리가 길게 나온 값을 저장하면서 완전탐색하면 문제를 해결할 수 있다.

```c++

int n, m;
int board[55][55];

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        string s;
        cin >> s;
        for (int j = 0; j < m; j++) {
            if (s[j] == 'L') board[i][j] = 0;
            else board[i][j] = 1;
        }
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (board[i][j] == 1) continue;
            int dist[55][55];
            for (int i = 0; i < n; i++) {
                fill(dist[i], dist[i] + m, -1);
            }

            queue<pair<int, int>> q;
            q.push({ i,j });
            dist[i][j] = 0;

            int maxi = 0;

            while (!q.empty()) {
                auto cur = q.front(); q.pop();
                for (int dir = 0; dir < 4; dir++) {
                    int ny = cur.Y + dy[dir];
                    int nx = cur.X + dx[dir];
                    if (ny < 0 || ny >= n || nx < 0 || nx >= m) continue;
                    if (dist[ny][nx] != -1 || board[ny][nx] == 1) continue;
                    dist[ny][nx] = dist[cur.Y][cur.X] + 1;
                    q.push({ ny, nx });
                    if (maxi < dist[ny][nx]) maxi = dist[ny][nx];
                }
            }

            ans = max(ans, maxi);

        }
    }
    cout << ans;

}

```
