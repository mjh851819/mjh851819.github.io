---
title: "BOJ 1911 흙길 보수하기 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 1911 흙길 보수하기 C++

### 문제

어젯밤 겨울 캠프 장소에서 월드 본원까지 이어지는, 흙으로 된 비밀길 위에 폭우가 내려서 N(1 ≤ N ≤ 10,000)개의 물웅덩이가 생겼다. 월드학원은 물웅덩이를 덮을 수 있는 길이가 L(1 ≤ L ≤ 1,000,000)인 널빤지들을 충분히 가지고 있어서, 이들로 다리를 만들어 물웅덩이들을 모두 덮으려고 한다. 물웅덩이들의 위치와 크기에 대한 정보가 주어질 때, 모든 물웅덩이들을 덮기 위해 필요한 널빤지들의 최소 개수를 구하여라.

### 힌트

```
111222..333444555.... // 길이 3인 널빤지
.MMMMM..MMMM.MMMM.... // 웅덩이
012345678901234567890 // 좌표
```

### 입력

첫째 줄에 두 정수 N과 L이 들어온다.

둘째 줄부터 N+1번째 줄까지 총 N개의 줄에 각각의 웅덩이들의 정보가 주어진다. 웅덩이의 정보는 웅덩이의 시작 위치와 끝 위치로 이루어진다. 각 위치는 0 이상 1,000,000,000 이하의 정수이다. 입력으로 주어지는 웅덩이는 겹치지 않는다.

### 출력

첫째 줄에 모든 물웅덩이들을 덮기 위해 필요한 널빤지들의 최소 개수를 출력한다.

---

### _풀이_

그리디로 시간복잡도를 줄여 해결할 수 있는 문제였다.

힌트가 조금 과한감이 없지 않아 있지만, 힌트를 참고해서 풀이법을 생각해보면 웅덩이를 막기위해 판자를 놓았을때 웅덩이를 벗어난 만큼에 대한 판자의 좌표를 신경쓰면서 최소 판자의 갯수를 구하면 된다.

좌표가 최대 10억까지 존재하므로 일일히 배열로 체크할 수는 없고, 물웅덩이의 좌표를 시작점을 기준으로 정렬함으로써 앞에 위치한 물웅덩이부터 판자를 놓을 수 있도록 세팅한다.

시작점에서부터 판자를 낭비하지 않도록 웅덩이를 채우면서 각 웅덩이를 채웠을때 판자가 놓인 좌표를 매번 저장해놓고, 다음 웅덩이를 채울때 해당 판자가 이미 웅덩이를 어느정도 덮어뒀다면 이를 고려하여 판자를 배치함으로써 판자의 갯수를 절약할 수 있다.

```c++

int n, l;
vector<pair<int, int>> arr;

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> l;
    for (int i = 0; i < n; i++) {
        int u, v;
        cin >> u >> v;
        arr.push_back({ u,v });
    }

    sort(arr.begin(), arr.end());

    int en = 0;
    int cnt = 0;
    for (auto [u, v] : arr) {
        int st = max(en, u);
        if (st - 1 >= v) continue;

        int len = v - st;
        int tmp = len / l + (len % l ? 1 : 0);
        cnt += tmp;
        en = st + (tmp * l);
    }

    cout << cnt;

}

```
