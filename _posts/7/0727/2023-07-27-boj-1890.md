---
title: "BOJ 1890 점프 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 1890 점프 C++

### 문제

N×N 게임판에 수가 적혀져 있다. 이 게임의 목표는 가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 점프를 해서 가는 것이다.

각 칸에 적혀있는 수는 현재 칸에서 갈 수 있는 거리를 의미한다. 반드시 오른쪽이나 아래쪽으로만 이동해야 한다. 0은 더 이상 진행을 막는 종착점이며, 항상 현재 칸에 적혀있는 수만큼 오른쪽이나 아래로 가야 한다. 한 번 점프를 할 때, 방향을 바꾸면 안 된다. 즉, 한 칸에서 오른쪽으로 점프를 하거나, 아래로 점프를 하는 두 경우만 존재한다.

가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 이동할 수 있는 경로의 개수를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 게임 판의 크기 N (4 ≤ N ≤ 100)이 주어진다. 그 다음 N개 줄에는 각 칸에 적혀져 있는 수가 N개씩 주어진다. 칸에 적혀있는 수는 0보다 크거나 같고, 9보다 작거나 같은 정수이며, 가장 오른쪽 아래 칸에는 항상 0이 주어진다.

### 출력

가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 문제의 규칙에 맞게 갈 수 있는 경로의 개수를 출력한다. 경로의 개수는 263-1보다 작거나 같다.

---

### _풀이_

**다이나믹 프로그래밍, 재귀, DFS**

문제의 완전탐색 풀이법은 아래와 같다.

0,0 에서 문제의 조건대로 재귀로 DFS를 실행하여 목적지에 닿았을 경우 1을 return해주고 해당 값을 누적하여 경로의 수를 구할 수 있다.

그러나 n이 최대 100이기 때문에 시간초과가 발생하고 이는 메모제이션으로 해결할 수 있다.

탐색 중 최초에 목적지에 도착할 경우 지나쳐온 모든 경로에 목적지까지 가는 경로가 한가지 존재한다는 뜻의 1을 표시해 두고 해당 경로에 다시 방문할 경우 더이상 탐색을 진행하지 않고 목적지까지의 경로 갯수만 return하여 시간 복잡도를 줄일 수 있다.

```c++

int board[105][105];
ll dp[105][105];
int n;

ll dfs(int y, int x) {
    if (board[y][x] == 0) {
        if (y == n - 1 && x == n - 1) return 1;
        else return 0;
    }

    if (dp[y][x] != -1) {
        return dp[y][x];
    }

    dp[y][x] = 0;

    for (int dir = 0; dir < 2; dir++) {
        int ny = y + (dy[dir] * board[y][x]);
        int nx = x + (dx[dir] * board[y][x]);
        if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;
        dp[y][x] += dfs(ny, nx);
    }

    return dp[y][x];
}

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    memset(dp, -1, sizeof(dp));

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> board[i][j];
        }
    }

    cout << dfs(0, 0);
}

```
