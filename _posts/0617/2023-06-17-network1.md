---
title: "네트워크 4-1 네트워크 계층"

categories:
  - Network
tags:
  - Network
---

> 이 글은 KOCW에서 제공하는 한양대학교 이석복 교수님의 컴퓨터 네트워크 강의를 기반으로 내용을 정리하고 복습하기 위한 용도로 작성되었습니다.

## Network Layer

> 전송계층에서 받은 데이터를 내려받는 계층. 전송계층에서 받은 세그먼트는 ip 패킷이라는 네트워크 계층에서 사용하는 데이터 단위안에 담긴다. 네트워크 계층에서 크게 알아볼 부분은 ip프로토콜과 라우터의 라우팅 등이 있다.

#### 1. 네트워크 계층이란?

---

> 전송계층에서는 양 끝단에 존재하는 프로세스와 프로세스간의 데이터 전송에 대해서 자세히 공부했다. 그 과정에서 데이터가 어떤 라우터를 거쳐가는지 경로에 대해서는 신경쓰지 않았다.

> 네트워크 계층에서는 출발지부터 목적지까지 어떻게 데이터가 전달되는지에 대해서 공부한다.

- 현대 라우터들은 네트워크 계층까지만 구현되어있다. 따라서 어딘가에서 전달된 데이터의 패킷을 보고 다음목적지를 정해서 데이터를 다시 전송하는것이 네트워크 계층의 역할이다.
- 우리는 애플리케이션 계층과 전송 계층에서 프로세스와 프로세스간의 메세지 전달을 위해 전송계층이 애플리케이션 계층에게 tcp/udp 두가지 중 하나의 기능을 제공한다고 배웠다.
- 네트워크 계층도 목적지 프로세스가 존재하는 호스트의 머신에 패킷을 전송하는 기능을 전송계층에게 제공한다.

#### 2. 라우터의 2가지 기능

---

**fowarding과 routing**

- fowarding: 패킷을 받아서 패킷의 다음 목적지까지 패킷을 전달하는 것.
- routing: 패킷의 목적지를 확인하고 fowarding table에 따라서 어떤 링크에 패킷을 보낼지 알아내는것
- fowarding table은 어떻게 만들까? 이때 routing 알고리즘이 사용된다.
- 따라서 라우팅이란 데이터의 출발지부터 목적지까지 어떤경로로 보낼지 설정하는것이고 그 데이터를 보내는것을 포워딩이라고 부르는 것이다.

![5-1](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/c06d3c7e-5b2e-4240-b5ef-90ab7f782d87)

- _Longest prefix matching_

  - fowarding table에는 특정한 주소가 설정되어 있는게 아니고 특정 주소의 범위가 output link와 맵핑되어있다.
  - 실제 테이블은 특정주소의 일정부분만 매칭시켜서 output link가 어딘지 알 수 있게 설정되어 있는데 이때 여러 키에 매칭되는 값이 있을 수 있다.
  - 이럴땐 가장 길게 매칭되는 키를 찾아서 해당하는 링크로 데이터를 전송하도록 하는것이 Longest prefix matching다.

#### 3. 라우팅의 구조

---

- 라우터의 구조에서 실제 데이터들이 오가는 영역을 data plane, 라우팅 알고리즘을 위한 데이터들이 오가는 영역을 control plane이라고 한다.
- 라우팅 알고리즘에 의해서 fowarding table이 완성되면 각각의 input port로 table이 전달된다.
- input port는 데이터가 들어오면 헤더에 담긴 주소를 fowading table과 비교하여 올바른 output link로 데이터를 전달한다.

#### 4. Ip struct

---

**ip datagram format**

![5-2](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/2c78926c-7333-42be-b8e6-e0fda67773d3)

1. ip version
2. header length
3. type of service
4. time to live : 패킷이 출발지로부터 발송된 이후에 얼만큼 많은 홉을 거칠 수 있는지 표시해놓은 값 ( 최대 n개의 라우터를 거칠 수 있다./ 0이 되면 드랍 ).
   > 라우팅 알고리즘에 의해 사이클이 발생했을때를 대비하기 위한 필드이다.
5. upper layer: 리시버가 패킷을 받았을 때 데이터를 전송계층으로 올려야하는데 tcp인지 udp인지 구분하기 위한 값.
6. length
7. checksum: 에러확인용 필드.
8. 32bit source / dest IP address : 출발지와 목적지의 주소.
   > 헤더크기는 TCP에서 20바이트 + IP에서 20바이트 = 40바이트 + 애플리케이션 계층의 헤더 값을 가진다
   > 중간에 생략한 16-bits identifier, flgs, fragment offset은 이후 챕터에서 설명한다.

#### 5. IP(internet protocol)

---

![5-3](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/c44cc19a-76fc-4c51-a341-496fba597e11)

- 32비트의 유니크한 번호, 보통 10진수로 8비트씩 4번 끊어서 표현한다.
  > 이러한 번호를 어떻게 생성하고 가지고 있을 것인가? 정말 랜덤하게 변수를 생성해서 저장한다면 라우터의 foward table이 감당할 수 없을것이다.
- 따라서 ip주소 앞의 24비트는 네트워크번호로 마지막 8비트는 그 네트워크 안의 호스트의 번호로 구분는 방식으로 체계적으로 관리한다.
- 따라서 같은 네트워크 안에 있는 호스트의 ip주소는 앞부분이 같다.
  > 12.34.125.0/24 --> 24-bit prefix 의 뜻이다. 앞 24비트는 네트워크 주소를 뜻하는 번호라는 의미이다.
- **subnet mask**: ip주소에서 어디까지가 네트워크 주소를 알려주는지 표시하기 위한 mask.
  > ex 255.255.255.0
- 이러한 ip주소 설정법에 의해서 fowarding table이 훨신 간단해진다.

#### 5-1. ip주소와 네트워크

---

- 과거엔 네트워크 주소를 만드는 엄격한 기준이 존재했다.

![5-4](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/ddb0d3b7-2dcd-4609-bd0c-b70030836c90)

- class A 네트워크는 2^7개 존재할 수 있고 네트워크당 호스트는 2^24만큼 존재할 수 있다.
- 이는 전세계의 네트워크 수에 비하면 턱없이 부족하다.
- 또한 classA와 B,C 사이에 보유할 수 있는 호스트의 개수 또한 천차만별이기에 네트워크가 부족하거나 낭비되는 사태가 일어났다.
- 따라서 현재는 자유로운 범위의 prefix를 혀용하는 classless 방식을 사용한다.

![5-5](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/50a2cc9a-0009-48f1-a607-273778a609bb)

- ip주소와 ip마스크를 잘 살펴보자. (subnet mask에 254가 있는 이유)
- 이제 우리는 fowarding table에 각 네트워크의 prefix가 들어가 있다는 사실을 알 수 있고, 왜 longest prefix matching을 사용하는지 자연스럽게 알 수 있다.

  > network prefix는 흔히 **subnet(서브넷)**이라고도 부른다.

- subnet의 구체적인 정의: 중간에 라우터를 거치지 않고 도착할 수 있는 호스트의 집합.

**중요 : ip주소는 host의 주소가 아니다!**

- ip주소는 host를 지칭하는것이 아니라 네트워크 인터페이스를 지칭하는것이다.
- 간혹 개인 컴퓨터마다 ip주소가 있기에 ip주소가 특정 host의 주소라고 생각하는 경우가 있는데, 이해하기 쉽게 설명하자면 우리는 컴퓨터를 조립할때 본체에 ip카드라는것을 넣고 랜선을 연결한다 이것을 머신에 네트워크 인터페이스를 연결한다고 생각하면 된다.
- 이렇게 연결된 인터페이스에 대한 주소가 ip주소이다.
- 여기서 발생하는 "ip는 호스트의 주소"라는 점과 다른점은 인터페이스를 여러개 연결하면 ip주소가 여러개일 수 있다는 점이다. 그것이 바로 라우터다.
- 라우터는 수많은 네트워크 인터페이스가 연결되어있기 때문에 각각의 인터페이스마다
  별개의 ip주소가 존재한다.
- 따라서 라우터는 여러개의 서브넷에 속한다고 할 수 있다.
