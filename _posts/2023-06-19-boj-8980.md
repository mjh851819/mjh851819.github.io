---
title: "BOJ 8980 택배 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 8980 택배 C++

문제

> 아래 그림과 같이 직선 도로상에 왼쪽부터 오른쪽으로 1번부터 차례대로 번호가 붙여진 마을들이 있다. 마을에 있는 물건을 배송하기 위한 트럭 한 대가 있고, 트럭이 있는 본부는 1번 마을 왼쪽에 있다. 이 트럭은 본부에서 출발하여 1번 마을부터 마지막 마을까지 오른쪽으로 가면서 마을에 있는 물건을 배송한다.

![prob](https://upload.acmicpc.net/bfa825aa-3abf-4012-96bf-55af2f76fb26/-/preview/)

> 각 마을은 배송할 물건들을 박스에 넣어 보내며, 본부에서는 박스를 보내는 마을번호, 박스를 받는 마을번호와 보낼 박스의 개수를 알고 있다. 박스들은 모두 크기가 같다. 트럭에 최대로 실을 수 있는 박스의 개수, 즉 트럭의 용량이 있다. 이 트럭 한대를 이용하여 다음의 조건을 모두 만족하면서 최대한 많은 박스들을 배송하려고 한다.

> 조건 1: 박스를 트럭에 실으면, 이 박스는 받는 마을에서만 내린다.
> 조건 2: 트럭은 지나온 마을로 되돌아가지 않는다.
> 조건 3: 박스들 중 일부만 배송할 수도 있다.
> 마을의 개수, 트럭의 용량, 박스 정보(보내는 마을번호, 받는 마을번호, 박스 개수)가 주어질 때, 트럭 한 대로 배송할 수 있는 최대 박스 수를 구하는 프로그램을 작성하시오. 단, 받는 마을번호는 보내는 마을번호보다 항상 크다.

입력

> 입력의 첫 줄은 마을 수 N과 트럭의 용량 C가 빈칸을 사이에 두고 주어진다. N은 2이상 2,000이하 정수이고, C는 1이상 10,000이하 정수이다. 다음 줄에, 보내는 박스 정보의 개수 M이 주어진다. M은 1이상 10,000이하 정수이다. 다음 M개의 각 줄에 박스를 보내는 마을번호, 박스를 받는 마을번호, 보내는 박스 개수(1이상 10,000이하 정수)를 나타내는 양의 정수가 빈칸을 사이에 두고 주어진다. 박스를 받는 마을번호는 보내는 마을번호보다 크다.

출력

> 트럭 한 대로 배송할 수 있는 최대 박스 수를 한 줄에 출력한다.

---

_풀이_

그리디 문제이며 구글을 한참동안 검색하고 공부해서 해결했다.

아직까지 완벽한 원리를 이해하진 못했으나 이 문제가 그리디인 이유는 다음과 같다.

- 짐을 쪼개서 가져갈 수 있다.
- 한번 방문한 도시에는 다시 돌아올 수 없으며 배송지와 도착지가 오름차순이다.

해당 문제를 해결하기 위한 풀이법은 다음과 같다.

- 도착지, 출발지, 짐의 양 을 tuple에 담아서 오름차순으로 정렬한다. 도착지가 가까운 순서로 정렬하는 것이 핵심이다.
  > 짐을 쪼개서 들 수 있으므로 출발지에서 가까운순서로 항상 짐을 꽉꽉채워서 가야하기 때문이다.
- 정렬된 배열에서의 값과 현재 경로에서의 용량을 비교하여 담을 수 있는만큼 최대한 채워 나간다.

아직까지 정확한 원리를 알 수 없어서 그저 풀이법을 익혀두는 수 밖에 없는 문제였다.
시간이 지난 후 다시 풀이해봐야 할 것 같다.

```c++

int n, c, m;
vector<tuple<int, int, int>> arr;
int s[2005];

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> c >> m;
    for (int i = 0; i < m; i++) {
        int q, w, e;
        cin >> q >> w >> e;
        arr.push_back({ w,q,e });
    }

    sort(arr.begin(), arr.end());
    int ans = 0;
    for (auto [en, st, cost] : arr) {
        int cap = cost;
        for (int i = st; i < en; i++) {
            cap = min(c - s[i], cap);
        }
        for (int i = st; i < en; i++) {
            s[i] += cap;
        }
        ans += cap;
    }

    cout << ans;
}


```
