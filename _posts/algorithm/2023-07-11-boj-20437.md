---
title: "BOJ 20437 문자열 게임 2 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 20437 문자열 게임 2 C++

문제

> 작년에 이어 새로운 문자열 게임이 있다. 게임의 진행 방식은 아래와 같다.

1. 알파벳 소문자로 이루어진 문자열 W가 주어진다.
2. 양의 정수 K가 주어진다.
3. 어떤 문자를 정확히 K개를 포함하는 가장 짧은 연속 문자열의 길이를 구한다.
4. 어떤 문자를 정확히 K개를 포함하고, 문자열의 첫 번째와 마지막 글자가 해당 문자로 같은 가장 긴 연속 문자열의 길이를 구한다.

> 위와 같은 방식으로 게임을 T회 진행한다.

입력

> 문자열 게임의 수 T가 주어진다. (1 ≤ T ≤ 100)

> 다음 줄부터 2개의 줄 동안 문자열 W와 정수 K가 주어진다. (1 ≤ K ≤ |W| ≤ 10,000)

출력

> T개의 줄 동안 문자열 게임의 3번과 4번에서 구한 연속 문자열의 길이를 공백을 사이에 두고 출력한다.

> 만약 만족하는 연속 문자열이 없을 시 -1을 출력한다.

---

_풀이_

이분탐색과 완전탐색을 사용해서 해결할 수 있는 문제였다.

문제를 풀기 전 알아둬야 할 점은,

'어떤 문자를 정확히 K개를 포함하는 가장 짧은 연속 문자열'은 반드시 첫번재 문자와 마지막 문자가 같다.

따라서 모든 알파벳에 대해서 아래와 같은 이분탐색을 실시한다. 0. st = 0, en = 0의 문자열의 인덱스를 지정한다.

1. 문자열의 처음부터 체크하면서(en: 0 ~ w.size() - 1) 현재 알파벳 cur이 k번 나올때까지 w[en]을 체크한다.
2. cur이 k번 나왔다면 st를 늘려가면서 w[st]가 cur이 될때까지 st를 늘린다.
3. 그렇게 찾은 sub 문자열의 길이의 최댓값과 최솟값을 저장한다.

위 과정을 거치면 '처음과 끝이 같은 알파벳이며 해당 알파벳이 반드시 k번 등장하는 문자열' 의 모든 경우의 수를 체크할 수 있으며 이 문자열 길이들의 최댓값과 최솟값을 출력하면 된다.

```c++

int t;
string s;

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> t;
    while (t--) {
        int k;
        int size;
        int ans1 = 10005, ans2 = 0;

        cin >> s >> k;
        size = s.size();

        for (int cur = 0; cur <= 25; cur++) {

            int cnt = 0;
            int en = 0;
            int len = 0;
            for (int st = 0; st < size; st++) {
                while (en < size && cnt < k) {
                    if (s[en] - 'a' == cur) cnt++;
                    len++;
                    en++;
                }
                len--;
                if (s[st] - 'a' == cur && k == cnt) {
                    cnt--;
                    ans1 = min(ans1, len + 1);
                    ans2 = max(ans2, len + 1);
                }

            }
        }
        if (ans1 == 10005 && ans2 == 0) cout << -1 << '\n';
        else cout << ans1 << " " << ans2 << '\n';
    }

}

```
