---
title: "BOJ 2098 외판원 순회 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 2098 외판원 순회 C++

### 문제

외판원 순회 문제는 영어로 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 여러 가지 변종 문제가 있으나, 여기서는 가장 일반적인 형태의 문제를 살펴보자.

1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.

각 도시간에 이동하는데 드는 비용은 행렬 W[i][j]형태로 주어진다. W[i][j]는 도시 i에서 도시 j로 가기 위한 비용을 나타낸다. 비용은 대칭적이지 않다. 즉, W[i][j] 는 W[j][i]와 다를 수 있다. 모든 도시간의 비용은 양의 정수이다. W[i][i]는 항상 0이다. 경우에 따라서 도시 i에서 도시 j로 갈 수 없는 경우도 있으며 이럴 경우 W[i][j]=0이라고 하자.

N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 도시의 수 N이 주어진다. (2 ≤ N ≤ 16) 다음 N개의 줄에는 비용 행렬이 주어진다. 각 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0이 주어진다. W[i][j]는 도시 i에서 j로 가기 위한 비용을 나타낸다.

항상 순회할 수 있는 경우만 입력으로 주어진다.

### 출력

첫째 줄에 외판원의 순회에 필요한 최소 비용을 출력한다.

---

### _풀이_

참고 자료: [TSP](https://hagisilecoding.tistory.com/150)

NP-hard 문제인 외판원 문제, TSP(Traveling Salesman Problem)이다.

원래는 브루트 포스로 해결해야 하는 문제이나, n이 최대 16으로 브루트 포스 알고리즘으로 해결하려 할 시 16!으로 시간초과를 받는다.

따라서 중간에 중복 계산을 메모제이션으로 해결하여 시간복잡도를 해결해야 하는데, 이때 **비트마스킹과 dp**를 활용한다.

우선 기본적인 아이디어는 출발점에 대해 모든 경로에 대한 완전탐색을 기반으로 시작한다.
단, 시작점은 신경쓰지 않고 0번 노드에서 시작하는 것으로 가정한다.
문제 특성상 순회가 가능한 간선 set만 주어지므로 어느 노드에서 출발 하던지 간에 같은 최소 순회 거리가 나오기 때문이다.

아래는 문제를 설명하기 위한 변수들이다.

A : 노드들의 부분집합들.
cur : 현재 노드
dp[cur][A]: 0번 노드에서 출발 했고 A마을들을 방문하여 현재 cur에 위치하는 상태에서, **나머지 미방문 노드들만 방문하여 다시 출발지로 돌아갔을때의 간선들의 합.**

dp 테이블의 쓰임새를 이해하는 것이 중요하다.
cur이 3이고 A가 0000111이이서 1,2,3번 마을을 이미 방문했고 3,4,5,6 마을을 방문해야 하는 상황에서 dp[3][0000111]의 값은 3번 마을에서 4,5,6,7번 마을을 방문하고 다시 0번 마을로 돌아올때 순회 거리의 최솟값이 저장된다.
즉, 다음으로 해야할 연산들의 결과를 저장해놓은 테이블이다.

테이블 구조가 조금 기이하지만 메모제이션을 사용하기 위해서 설계된 테이블이기 때문에 반드시 이해하고 넘어가야 코드가 더 잘 보인다.

이 때문에 코드의 재귀함수는 dp[0][0000001] (n = 7일때)부터 시작하여 해당값이 결국 최솟값이 된다.
해당 dp 테이블의 의미가 **현재 0번 마을에서 나머지 1~6번 마을 노드들을 최소 거리로 순회한 후 0번 마을로 다시 돌아오는 값** 이기 때문이다.

해당 테이블을 이해했다면 재귀함수의 나머지 부분은

첫번째 if문은 현재 cur값과 방문할 예정인 노드들에 대한 연산이 이미 메모되어 있다면 바로 값을 반환해 주는 부분이고

두번째 if문은 기저값으로 0번 노드에서 모든 노드를 방문했을때 다시 0번 노드로 돌아가는 간선의 길이를 return해주는 부분이다.

for문 같은 경우는 완전탐색을 돌리는 부분이며 이미 방문한 노드이거나 해당 노드로 이동할 수 없는 경우엔 탐색을 진행하지 않는다.

```c++

const int MAX = 17;

int n;
int adj[17][17];
int dp[17][1<<MAX];
int ans = INF;

int dfs(int cur, int state) {
    if (dp[cur][state] != -1) return dp[cur][state];
    if (state == (1 << n) - 1) {
        if (adj[cur][0] == 0) return INF;
        else return adj[cur][0];
    }
    dp[cur][state] = INF;

    for (int i = 0; i < n; i++) {
        if (state & (1 << i)) continue;
        if (adj[cur][i] == 0) continue;
        int vis = state | (1 << i);
        dp[cur][state] = min(dp[cur][state], adj[cur][i] + dfs(i, vis));
    }
    return dp[cur][state];
}

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> adj[i][j];
        }
    }
    memset(dp, -1, sizeof(dp));
    cout << dfs(0, 1);

}

```
