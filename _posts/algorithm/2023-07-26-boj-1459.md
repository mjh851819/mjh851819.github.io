---
title: "BOJ 1459 걷기 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 1459 걷기 C++

### 문제

세준이는 학교에서 집으로 가려고 한다. 도시의 크기는 무한대이고, 도시의 세로 도로는 모든 정수 x좌표마다 있고, 가로 도로는 모든 정수 y좌표마다 있다. 세준이는 현재 (0, 0)에 있다. 그리고 (X, Y)에 위치한 집으로 가려고 한다. 세준이가 걸을 수 있는 방법은 두가지 인데, 하나는 도로를 따라서 가로나 세로로 한 블록 움직여서 이번 사거리에서 저 사거리로 움직이는 방법이고, 블록을 대각선으로 가로지르는 방법이 있다.

세준이가 집으로 가는데 걸리는 최소시간을 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 집의 위치 X Y와 걸어서 한 블록 가는데 걸리는 시간 W와 대각선으로 한 블록을 가로지르는 시간 S가 주어진다. X와 Y는 1,000,000,000보다 작거나 같은 음이 아닌 정수이고, W와 S는 10,000보다 작거나 같은 자연수이다.

### 출력

첫째 줄에 세준이가 집에가는데 걸리는 최소시간을 출력한다.

---

### _풀이_

그리디로 해결할 수 있는 수학문제였다.

문제의 이동 방식은 직선이동과 대각선이동 2가지이다.

이때 만약 직선이동을 2번 실시한 시간이 대각선 이동 시간보다 적다면 대각선 이동 시간을 직선이동을 2번한 시간으로 대체할 수 있다.

추가로 직선 이동을 2번하여 한 방향으로 2번 이동한 시간과 대각선 이동을 2번하여 직선으로 2칸 이동한 시간을 비교하여 '직선 2칸 이동' 시간을 최솟값으로 맞출 수 있다.

따라서 해당 문제에서 움직이는 방식은 3가지로, 직선 1칸 이동, 대각선 1칸 이동, 직선 2칸 이동 이다.

좌표는 0,0 에서 시작이므로 n,m (n < m) 일때 대각선 이동으로 n,n까지 이동한 후, 나머지 직선이동을 직선 2칸 이동, 직선 1칸 이동으로 최솟값으로 맞춰 이동하면 최소시간을 구할 수 있다.

```c++

ll x, y, w, s;

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> x >> y >> w >> s;
    s = min(s, 2 * w);
    int w2 = min(2 * w, 2 * s);

    ll a = min(x, y);
    ll b = max(x, y) - min(x, y);

    ll b1 = b / 2;
    ll b2 = b % 2;

    ll ans = 0;
    ans += (a * s);
    ans += (b1 * w2);
    ans += (b2 * w);

    cout << ans;

}

```
