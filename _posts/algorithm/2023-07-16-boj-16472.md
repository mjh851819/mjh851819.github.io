---
title: "BOJ 16472 고냥이 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 16472 고냥이 C++

### 문제

고양이는 너무 귀엽다. 사람들은 고양이를 너무 귀여워했고, 결국 고양이와 더욱 가까워지고 싶어 고양이와의 소통을 위한 고양이 말 번역기를 발명하기로 했다. 이 번역기는 사람의 언어를 고양이의 언어로, 고양이의 언어를 사람의 언어로 바꾸어 주는 희대의 발명품이 될 것이다.

현재 고양이말 번역기의 베타버전이 나왔다. 그러나 이 베타버전은 완전 엉망진창이다. 베타버전의 번역기는 문자열을 주면 그 중에서 최대 N개의 종류의 알파벳을 가진 연속된 문자열밖에 인식하지 못한다. 굉장히 별로지만 그나마 이게 최선이라고 사람들은 생각했다. 그리고 문자열이 주어졌을 때 이 번역기가 인식할 수 있는 최대 문자열의 길이는 얼마인지가 궁금해졌다.

고양이와 소통할 수 있도록 우리도 함께 노력해보자.

### 입력

첫째 줄에는 인식할 수 있는 알파벳의 종류의 최대 개수 N이 입력된다. (1 < N ≤ 26)

둘째 줄에는 문자열이 주어진다. (1 ≤ 문자열의 길이 ≤ 100,000) 단, 문자열에는 알파벳 소문자만이 포함된다.

### 출력

첫째 줄에 번역기가 인식할 수 있는 문자열의 최대길이를 출력한다.

---

### _풀이_

투포인터 알고리즘으로 해결할 수 있는 문제였다.

문자열을 st와 en의 인덱스를 두고 en을 늘려가며 st-en의 부분 문자열을 투포인터로 탐색한다.

부분 문자열의 길이가 늘어날때 마다 check 배열을 사용해서 사용된 알파벳의 종류를 체크하며 인식할 수 있는 최대 알파벳을 초과하려하기 직전에 en의 증가를 멈추고 부분 문자열의 최댓값을 갱신한다.

이후 st값을 늘려가면서 부분 문자열의 길이를 줄여가면서 인식할 수 있는 문자열의 갯수가 줄어드는 시점에 다시 en을 늘려가며 탐색을 시작하면 시간내에 탐색을 마칠 수 있다.

```c++

int n;
string s;
int check[27];

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> s;

    int en = 0;
    int cnt = 0;
    int len = 0;
    int maxi = 0;
    for (int st = 0; st < s.size(); st++) {
        while (en < s.size() && cnt <= n) {
            if (check[s[en] - 'a'] == 0) {
                if (cnt == n) break;
                else cnt++;
            }
            check[s[en] - 'a']++;
            len++;
            en++;
        }
        maxi = max(maxi, len);
        check[s[st] - 'a']--;
        if (check[s[st] - 'a'] == 0) cnt--;
        len--;

    }

    cout << maxi;

}

```
