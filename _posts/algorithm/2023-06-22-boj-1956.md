---
title: "BOJ 1956 운동 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 1956 운동 C++

문제

> V개의 마을와 E개의 도로로 구성되어 있는 도시가 있다. 도로는 마을과 마을 사이에 놓여 있으며, 일방 통행 도로이다. 마을에는 편의상 1번부터 V번까지 번호가 매겨져 있다고 하자.

> 당신은 도로를 따라 운동을 하기 위한 경로를 찾으려고 한다. 운동을 한 후에는 다시 시작점으로 돌아오는 것이 좋기 때문에, 우리는 사이클을 찾기를 원한다. 단, 당신은 운동을 매우 귀찮아하므로, 사이클을 이루는 도로의 길이의 합이 최소가 되도록 찾으려고 한다.

> 도로의 정보가 주어졌을 때, 도로의 길이의 합이 가장 작은 사이클을 찾는 프로그램을 작성하시오. 두 마을을 왕복하는 경우도 사이클에 포함됨에 주의한다.

입력

> 첫째 줄에 V와 E가 빈칸을 사이에 두고 주어진다. (2 ≤ V ≤ 400, 0 ≤ E ≤ V(V-1)) 다음 E개의 줄에는 각각 세 개의 정수 a, b, c가 주어진다. a번 마을에서 b번 마을로 가는 거리가 c인 도로가 있다는 의미이다. (a → b임에 주의) 거리는 10,000 이하의 자연수이다. (a, b) 쌍이 같은 도로가 여러 번 주어지지 않는다.

출력

> 첫째 줄에 최소 사이클의 도로 길이의 합을 출력한다. 운동 경로를 찾는 것이 불가능한 경우에는 -1을 출력한다.

---

_풀이_

문제의 의도는 다음과 같다.  
1부터 V번 마을중 한 마을 n을 골라서 해당 마을에서 출발하여 다시 n으로 돌아오는 거리 중 최단거리를 찾아야한다.
시작마을에 가만히 있는경우는 당연히 없으며, 마을로 다시 돌아올 수 없는 경우도 존재한다.

플로이드 알고리즘으로 각 정점간의 거리를 한번에 구해둔 다음 모든 경우의 수에 대해서 최솟값을 구하면 간단하게 해결할 수 있는 문제였다.

```c++

int v, e;
int d[405][405];

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> v >> e;

    for (int i = 1; i <= v; i++) {
        fill(d[i], d[i] + v + 1, INF);
    }
    for (int i = 1; i <= v; i++) d[i][i] = 0;

    for (int i = 0; i < e; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = c;
    }

    for (int k = 1; k <= v; k++) {
        for (int i = 1; i <= v; i++) {
            for (int j = 1; j <= v; j++) {
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
            }
        }
    }

    int ans = INF;
    for (int i = 1; i <= v; i++) {
        for (int j = 1; j <= v; j++) {
            if (i == j) continue;
            if (d[i][j] == INF || d[j][i] == INF) continue;
            ans = min(ans, d[i][j] + d[j][i]);
        }
    }
    if (ans == INF) cout << -1;
    else cout << ans;

}


```
