---
title: "BOJ 1309 동물원 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 1309 동물원 C++

### 문제

어떤 동물원에 가로로 두칸 세로로 N칸인 아래와 같은 우리가 있다.

![1](https://www.acmicpc.net/upload/201004/dnfl.JPG)

이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다. 이 동물원 조련사는 사자들의 배치 문제 때문에 골머리를 앓고 있다.

동물원 조련사의 머리가 아프지 않도록 우리가 2\*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자. 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.

### 입력

첫째 줄에 우리의 크기 N(1≤N≤100,000)이 주어진다.

### 출력

첫째 줄에 사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하여라.

---

### _풀이_

**다이나믹 프로그래밍**

동물원의 우리가 아래로 한칸 추가될때마다 경우의수를 순차적으로 추가해주는 방식으로 문제를 해결할 수 있다.

우리가 한칸 추가되면 우리에 사자가 없는경우, 오른쪽에만 사자가 있는경우, 왼쪽에만 사자가 있는경우의 3가지 경우가 존재하므로 dp테이블도 해당 경우에 따라서 경우의 수를 관리한 후 마지막에 모든 경우의 수를 더해주면 된다.

```c++

int n;
int dp[100005][3];

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;

    dp[1][0] = 1; //없음
    dp[1][1] = 1; //왼쪽칸
    dp[1][2] = 1; //오른쪽칸

    for (int i = 2; i <= n; i++) {
        dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % 9901;
        dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % 9901;
        dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % 9901;
    }

    cout << (dp[n][0] + dp[n][1] + dp[n][2]) % 9901;


}

```
