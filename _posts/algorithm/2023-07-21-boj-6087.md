---
title: "BOJ 6087 레이저 통신 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 6087 레이저 통신 C++

### 문제

크기가 1×1인 정사각형으로 나누어진 W×H 크기의 지도가 있다. 지도의 각 칸은 빈 칸이거나 벽이며, 두 칸은 'C'로 표시되어 있는 칸이다.

'C'로 표시되어 있는 두 칸을 레이저로 통신하기 위해서 설치해야 하는 거울 개수의 최솟값을 구하는 프로그램을 작성하시오. 레이저로 통신한다는 것은 두 칸을 레이저로 연결할 수 있음을 의미한다.

레이저는 C에서만 발사할 수 있고, 빈 칸에 거울('/', '\')을 설치해서 방향을 90도 회전시킬 수 있다.

아래 그림은 H = 8, W = 7인 경우이고, 빈 칸은 '.', 벽은 '\*'로 나타냈다. 왼쪽은 초기 상태, 오른쪽은 최소 개수의 거울을 사용해서 두 'C'를 연결한 것이다.

```
7 . . . . . . .         7 . . . . . . .
6 . . . . . . C         6 . . . . . /-C
5 . . . . . . *         5 . . . . . | *
4 * * * * * . *         4 * * * * * | *
3 . . . . * . .         3 . . . . * | .
2 . . . . * . .         2 . . . . * | .
1 . C . . * . .         1 . C . . * | .
0 . . . . . . .         0 . \-------/ .
  0 1 2 3 4 5 6           0 1 2 3 4 5 6
```

### 입력

첫째 줄에 W와 H가 주어진다. (1 ≤ W, H ≤ 100)

둘째 줄부터 H개의 줄에 지도가 주어진다. 지도의 각 문자가 의미하는 것은 다음과 같다.

- .: 빈 칸
- \*: 벽
- C: 레이저로 연결해야 하는 칸
  'C'는 항상 두 개이고, 레이저로 연결할 수 있는 입력만 주어진다.

### 출력

첫째 줄에 C를 연결하기 위해 설치해야 하는 거울 개수의 최솟값을 출력한다.

---

### _풀이_

BFS로 해결할 수 있는 문제였다.

일반적인 BFS와는 조금 다른방식으로 해결해야한다.

이유는 각 칸을 방문했다는 체크를 하는 과정에서 같은칸을 방문하더라도 어떤 방향에서 들어왔는지에 따라 따로 체크해줘야 하기 때문이다.

즉, 같은 방향으로 같은칸에 방문했을때만 중복으로 처리하여 q에 넣지 않는 BFS를 구현해야 한다.

또한 dist배열은 이동거리를 메모하는 배열이 아닌 해당 칸까지 이동하는데 설치한 거울의 배열이다.

따라서 방문배열과는 따로 관리해줘야하며 (dist배열과 vis배열을 같은 의미로 두고 동시에 관리하던 기법을 사용하지 못한다) 같은방향으로 같은칸에 방문해도 설치한 거울의 숫자가 더 적다면 중복하여 q에 넣을 수 있다.

추가적으로 레이저는 좌, 우로는 꺾일 수 있지만 뒤로는 꺾일 수 없다. 따라서 현재 방향이 dir, 직전 방향이 d 일때 (d + 2) % 4 == dir 의 연산을 통해 전진, 좌회전, 우회전만을 탐색방향에 포함해야 한다.

BFS문제이지만 생소한 유형이었고 관리해야 하는 조건들이 꽤 많아서 어려움을 겪었던 문제였다.

```c++

char board[105][105];
int dist[105][105][4];
int vis[105][105][4];
int n, m;
vector<pair<int, int>> p;

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> m >> n;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            char c;
            cin >> c;
            board[i][j] = c;
            if (c == 'C') p.push_back({ i,j });
        }
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            fill(dist[i][j], dist[i][j] + 4, INF);
        }
    }

    queue<tuple<int, int, int, int>> q;
    for (int i = 0; i < 4; i++) {
        int ny = p[0].Y + dy[i];
        int nx = p[0].X + dx[i];
        if (nx < 0 || nx >= m || ny < 0 || ny >= n) continue;
        if (board[ny][nx] == '*') continue;
        q.push({ 0,ny,nx,i });
        dist[p[0].Y][p[0].X][i] = 0;
        vis[p[0].Y][p[0].X][i] = 1;
    }

    while (!q.empty()) {
        int y, x, d, cnt;
        tie(cnt, y, x, d) = q.front(); q.pop();
        for (int dir = 0; dir < 4; dir++) {
            if ((d + 2) % 4 == dir) continue;
            int ny = y + dy[dir];
            int nx = x + dx[dir];
            if (nx < 0 || nx >= m || ny < 0 || ny >= n) continue;
            if (board[ny][nx] == '*') continue;
            int k = cnt;
            if (d != dir) k++;
            if (vis[ny][nx][dir] == 1) continue;
            q.push({ k,ny,nx,dir });
            dist[ny][nx][dir] = k;
            vis[ny][nx][dir] = 1;
        }
    }

    cout << min({ dist[p[1].Y][p[1].X][0], dist[p[1].Y][p[1].X][1], dist[p[1].Y][p[1].X][2], dist[p[1].Y][p[1].X][3] });
}

```
