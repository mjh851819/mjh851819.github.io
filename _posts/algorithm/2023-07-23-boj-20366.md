---
title: "BOJ 20366 같이 눈사람 만들래? C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 20366 같이 눈사람 만들래? C++

### 문제

언니 엘자와 동생 안나에게는 N개의 눈덩이가 있다. 각 눈덩이 i (1 ≤ i ≤ N)의 지름은 Hi 이다. 하나의 눈사람은 두 개의 눈덩이로 구성되며, 눈덩이 하나를 아래에 두고 그 눈덩이보다 크지 않은 다른 눈덩이를 쌓아올리는 방식으로 만들 수 있다. 이때, 눈사람의 키는 두 눈덩이 지름의 합과 같다.

엘자와 안나는 눈덩이 N개 중 서로 다른 4개를 골라서 눈사람을 각각 1개씩, 총 2개를 만들려고 한다. 두 자매는 두 눈사람의 키의 차이가 작을수록 두 눈사람의 사이가 좋을 것이라고 믿는다. 우리는 엘자와 안나가 가장 사이좋은 두 눈사람을 만들기 위해서 도와주려고 한다.

주어진 N개의 눈덩이를 이용하여 만들 수 있는 두 눈사람의 키 차이 중 최솟값을 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 N (4 ≤ N ≤ 600)이 주어진다.

둘째 줄에는 각 눈덩이 i (1 ≤ i ≤ N)의 지름을 의미하는 정수 Hi (1 ≤ Hi ≤ 109)가 공백으로 구분되어 주어진다.

### 출력

만들 수 있는 두 눈사람의 키 차이 중 최솟값을 나타내는 정수를 출력하라.

---

### _풀이_

투 포인터와 정렬을 활용해서 해결할 수 있는 문제였다.

우선 최대 600개의 눈덩이에서 4개를 뽑는 조합으로 완전탐색을 구현할 경우 시간초과가 발생한다.

따라서 투포인터 개념을 활용해서 시간복잡도를 줄여야 한다.

우선 눈사람은 눈덩이 2개로 만들어지며, 어떤 눈덩이 2개를 골라도 반드시 눈사람 을 만들 수 있다.

따라서 중복되지 않는 눈덩이 2개를 모두 조합해놓은 tuple의 vector를 만들어 놓는다.

tuple의 구성은 다음과 같다 tuple<눈사람의 키, 첫번째 눈덩이의 인덱스, 두번째 눈덩이의 인덱스>, 이 tuple을 모아놓은 vector를 눈사람의 벡터라 하자.

우선 이 눈사람의 백터를 정렬한다.

정렬된 눈사람의 백터를 2중 for문을 사용하여 눈사람 1과 눈사람 2를 탐색한다.
이때 최초로 발견된 모두 서로 다른 눈덩이를 사용하는 눈사람 1, 2를 찾았을 경우 2중 for문의 내부 for문은 더이상 탐색할 필요가 없다. (눈사람의 벡터가 정렬되어 있기 때문에 더이상 탐색해도 눈사람의 키차이는 커지기 때문이다.)

이러한 방식으로 시간복잡도를 줄여가면서 눈사람의 최소 키차이를 구할 수 있다.

```c++

int n;
ll arr[605];
vector<tuple<ll, int, int>> v;

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            v.push_back({ arr[i] + arr[j], i, j });
        }
    }

    sort(v.begin(), v.end());

    ll mini = LINF;

    for (int i = 0; i < v.size(); i++) {
        for (int j = i + 1; j < v.size(); j++) {
            int c1, a1, b1, c2, a2, b2;
            tie(c1, a1, b1) = v[i];
            tie(c2, a2, b2) = v[j];
            if (a1 == a2 || a1 == b2 || b1 == a2 || b1 == b2) continue;
            if (mini > abs(c1 - c2)) {
                mini = abs(c1 - c2);
            }
            break;
        }
    }


    cout << mini;


}

```
