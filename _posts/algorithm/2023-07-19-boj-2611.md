---
title: "BOJ 2611 자동차경주 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 2611 자동차경주 C++

### 문제

자동차 경주로는 <그림 1>의 예와 같이 표현된다. 화살표는 각 지점을 잇는 도로를 의미하며 모든 도로는 일방통행 도로로 화살표 방향으로만 움직일 수 있다.

![1](https://www.acmicpc.net/upload/images/szO5Yfmfx1gD.jpg)

자동차 경주의 코스는 1번 지점에서 출발하여 다시 1번 지점으로 되돌아오는 것이다. 단, 중간에는 1번 지점을 지나서는 안 된다. 경주로는 1번 지점을 제외한 어느 지점에서 출발하여도 1번 지점을 지나가지 않고서는 같은 지점으로 돌아올 수 없도록 되어 있다. 또한 1번 지점에서 다른 모든 지점으로 갈 수 있고, 다른 모든 지점에서 1번 지점으로 갈 수 있다.

각 도로에는 <그림 2>의 예와 같이 그 도로를 지날 때 얻는 점수가 있다.

![2](https://www.acmicpc.net/upload/images/HR8SAQiB7ZapoXXo75XfRcrv.jpg)

1번 지점에서 출발하여 가장 많은 점수를 얻어 다시 1번 지점으로 돌아오는 팀이 우승을 하게 된다. 가장 많은 점수를 얻어 1번 지점으로 돌아오는 경로를 찾아 그 얻는 점수와 경로를 출력하는 프로그램을 작성하시오.

### 입력

첫째 줄에는 지점의 개수 N이 주어진다. 각 지점에는 1부터 N까지의 서로 다른 번호가 부여된다. 둘째 줄에는 도로의 개수 M이 주어진다. 이어 M개의 줄에는 p ,q ,r의 형식으로 도로의 정보가 주어지는데 이는 p번 지점부터 q번 지점으로 갈 수 있는 도로가 있고 그 도로에 부여된 점수가 r이라는 뜻이다. N은 1000이하의 자연수이고, p와 q는 1이상의 N이하의 자연수이며 r은 100이하의 자연수 이다. p와 q는 같지 않다.

### 출력

가장 많은 점수를 얻은 경로를 찾아, 첫째 줄에는 그 얻는 점수를 출력하고 둘째 줄에는 그 경로를 출력한다. 경로를 출력할 때는 지나는 지점들의 번호를 사이에 한 칸의 공백을 두어 출력한다. 출력하는 경로는 반드시 1번 지점에서 시작하여 1번 지점으로 끝나야 한다. 만약 같은 점수를 얻는 경로가 둘 이상일 경우 그 중 하나만 출력하면 된다.

---

### _풀이_

위상정렬로 해결할 수 있는 문제였다.

문제 자체가 위상정렬 문제임을 눈치채는것이 굉장히 까다로운 문제였다.

위상정렬은 기본적으로 사이클이 존재하면 사용할 수 없는 알고리즘이다.
그러나 문제의 조건을 잘 읽어보면

"경주로는 1번 지점을 제외한 어느 지점에서 출발하여도 1번 지점을 지나가지 않고서는 같은 지점으로 돌아올 수 없도록 되어 있다."

라는 조건에 의하여 1번 지점 외에는 사이클이 절대 형성되지 않는 구조임을 추측할 수 있으며

"1번 지점에서 다른 모든 지점으로 갈 수 있고 다른 모든 지점에서 1번 지점으로 갈 수 있다."

라는 조건에 의해서 위상정렬 초기 시작 노드를 1로 설정해두고 1번 노드의 차수가 0이되는 경우가 없게 설정하면 위상정렬 알고리즘을 수행할 수 있다.

따라서 위상정렬을 위한 준비를 하는 과정에서 고의적으로 1번 노드의 차수를 1늘려 1번 노드의 차수가 절대 1이 되지 않게 설정해두어야 한다.

이러한 초기값을 시작으로 위상정렬을 수행하면서 각 노드의 차수를 줄이는 과정에서 점수의 최댓값을 갱신해주고 최댓값이 갱신되면 pre[]배열을 통해서 직전 노드를 메모해 둠으로써 경로까지 탐색할 수 있다.

```c++

int n, m;
int dg[1005];
vector<pair<int, int>> adj[1005];
int sc[1005];
int pre[1005];

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int p, q, r;
        cin >> p >> q >> r;
        adj[p].push_back({ r,q });
        dg[q]++;
    }
    dg[1]++;

    queue<int> q;
    q.push(1);
    while (!q.empty()) {
        auto cur = q.front(); q.pop();
        for (auto [cost, v] : adj[cur]) {
            if (sc[v] < sc[cur] + cost) {
                sc[v] = sc[cur] + cost;
                pre[v] = cur;
            }
            dg[v]--;
            if (dg[v] == 0) q.push(v);
        }
    }
    cout << sc[1] << '\n';
    stack<int> st;
    int cur = pre[1];
    while (cur != 1) {
        st.push(cur);
        cur = pre[cur];
    }
    cout << 1 << " ";
    while (!st.empty()) {
        cout << st.top() << " ";
        st.pop();
    }
    cout << 1;


}

```
