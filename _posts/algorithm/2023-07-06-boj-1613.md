---
title: "BOJ 1613 역사 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 1613 역사 C++

문제

> 역사, 그 중에서도 한국사에 해박한 세준이는 많은 역사적 사건들의 전후 관계를 잘 알고 있다. 즉, 임진왜란이 병자호란보다 먼저 일어났으며, 무오사화가 기묘사화보다 먼저 일어났다는 등의 지식을 알고 있는 것이다.

> 세준이가 알고 있는 일부 사건들의 전후 관계들이 주어질 때, 주어진 사건들의 전후 관계도 알 수 있을까? 이를 해결하는 프로그램을 작성해 보도록 하자.

입력

> 첫째 줄에 첫 줄에 사건의 개수 n(400 이하의 자연수)과 알고 있는 사건의 전후 관계의 개수 k(50,000 이하의 자연수)가 주어진다. 다음 k줄에는 전후 관계를 알고 있는 두 사건의 번호가 주어진다. 이는 앞에 있는 번호의 사건이 뒤에 있는 번호의 사건보다 먼저 일어났음을 의미한다. 물론 사건의 전후 관계가 모순인 경우는 없다. 다음에는 사건의 전후 관계를 알고 싶은 사건 쌍의 수 s(50,000 이하의 자연수)이 주어진다. 다음 s줄에는 각각 서로 다른 두 사건의 번호가 주어진다. 사건의 번호는 1보다 크거나 같고, N보다 작거나 같은 자연수이다.

출력

> s줄에 걸쳐 물음에 답한다. 각 줄에 만일 앞에 있는 번호의 사건이 먼저 일어났으면 -1, 뒤에 있는 번호의 사건이 먼저 일어났으면 1, 어떤지 모르면(유추할 수 없으면) 0을 출력한다.

---

_풀이_

플로이드 알고리즘을 통해 우선순위를 매겨 해결할 수 있는 문제였다.

사건의 전후관계 a와 b가 주어질때 이를 a -> b의 단방향 노드와 간선 관계로 표현할 수 있다.

해당 정보들을 토대로 플로이드 알고리즘을 수행하여 나온 d[n][m] 테이블의 의미는 다음과 같다.

- n사건은 m사건보다 먼저 일어났으며 m사건까지 d[n][m]까지의 사건이 존재한다.

즉 모든 테이블을 채운 후에 d[n][m]과 d[m][n] 테이블을 확인하여 둘중 INF가 아닌 테이블을 찾아서 전후관계를 파악할 수 있으며 만약 둘 다 INF라면 전후관계 파악이 불가능한 경우다.

```c++

int n, k, s;
int d[405][405];

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        fill(d[i], d[i] + n + 1, INF);
    }
    for (int i = 1; i <= n; i++) d[i][i] = 0;

    for (int i = 0; i < k; i++) {
        int u, v;
        cin >> u >> v;
        d[u][v] = 1;
    }

    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
            }
        }
    }

    cin >> s;
    for (int i = 0; i < s; i++) {
        int u, v;
        cin >> u >> v;
        if (d[u][v] == INF && d[v][u] == INF) cout << 0 << '\n';
        else if (d[u][v] != INF) cout << -1 << '\n';
        else if (d[v][u] != INF) cout << 1 << '\n';
    }

}

```
