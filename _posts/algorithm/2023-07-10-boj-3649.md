---
title: "BOJ 3649 로봇 프로젝트 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 3649 로봇 프로젝트 C++

문제

> 상근이와 선영이는 학교 숙제로 로봇을 만들고 있다. 로봇을 만들던 중에 구멍을 막을 두 레고 조각이 필요하다는 것을 깨달았다.

구멍의 너비는 x 센티미터이고, 구멍에 넣을 두 조각의 길이의 합은 구멍의 너비와 정확하게 일치해야 한다. 정확하게 일치하지 않으면, 프로젝트 시연을 할 때 로봇은 부수어질 것이고 상근이와 선영이는 F를 받게 된다. 구멍은 항상 두 조각으로 막아야 한다.

지난밤, 상근이와 선영이는 물리 실험실에 들어가서 레고 조각의 크기를 모두 정확하게 재고 돌아왔다. 구멍을 완벽하게 막을 수 있는 두 조각을 구하는 프로그램을 작성하시오.

입력

> 입력은 여러 개의 테스트 케이스로 이루어져 있다.

> 각 테스트 케이스의 첫째 줄에는 구멍의 너비 x (1 ≤ x ≤ 20, x는 정수)가 주어진다. x의 단위는 센티미터이다.

> 다음 줄에는 물리 실험실에 있는 레고 조각의 수 n이 주어진다. (0 ≤ n ≤ 1000000)

> 다음 n개의 줄에는 레고 조각의 길이 ℓ이 주어진다. ℓ은 양의 정수이며, 단위는 나노미터이다. 블록의 길이는 10 센티미터 (100000000 나노미터)를 넘지 않는다.

출력

> 각 테스트 케이스마다 한 줄에 하나씩, 구멍을 완벽하게 막을 수 있는 두 조각이 없다면 'danger'를 출력한다. 막을 수 있는 경우에는 'yes ℓ1 ℓ2'를 출력한다. (ℓ1 ≤ ℓ2)

> 정답이 여러 개인 경우에는 |ℓ1 - ℓ2|가 가장 큰 것을 출력한다.

---

_풀이_

이분탐색을 통해 해결할 수 있는 문제였다.

우선 가장먼저 입력받은 x센티 미터를 나노미터로 변환해준다.

이후 입력받은 나노미터 단위의 블럭 배열을 정렬해준 후, lower_bound 탐색을 통해 A + B = x가 되는 블럭이 배열 내에 존재하는지 체크하면 된다.

이때 배열은 정렬되어 있기 때문에 항상 가장 첫번째에 발견되는 A + B = x의 A B블럭이 출력 조건에 부합하는 정답이 될 수 있다.

```c++

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int x, n;
    while (cin >> x >> n) {
        vector<int> v;
        x *= 10000000;
        for (int i = 0; i < n; i++) {
            int a;
            cin >> a;
            v.push_back(a);
        }
        sort(v.begin(), v.end());
        int l1 = -1, l2 = -1;
        for (int i = 0; i < v.size(); i++) {
            int idx = lower_bound(v.begin(), v.end(), abs(x - v[i])) - v.begin();
            if (idx != i && idx < v.size() && idx >= 0 && (x - v[i]) == v[idx]) {
                l1 = v[i];
                l2 = v[idx];
                break;
            }
        }

        if (l1 == -1 && l2 == -1) cout << "danger" << '\n';
        else cout << "yes " << l1 << " " << l2 << '\n';
    }

}

```
