---
title: "BOJ 4716 풍선 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 4716 풍선 C++

### 문제

전대프연 대회에서 문제를 푼 팀은 풍선을 받게 된다. 풍선은 사람이 직접 달아주기 때문에 자원 봉사자가 필요하다.

풍선은 방 A와 방 B에 보관되어 있다. 대회에 참가한 팀의 수는 총 N개이고, 앉아있는 자리는 서로 다르다. 어떤 팀은 방 A에 가깝고, 어떤 팀은 B에 더 가깝다. 

각 팀에게 달아줘야 하는 풍선의 수와 방 A와 B로부터의 거리가 주어진다. 이때, 모든 풍선을 달아주는데 필요한 이동 거리의 최솟값을 출력한다. 대회에서 풍선을 달아주는 사람은 매우 많고, 풍선은 한 가지 색상을 여러 개 달아준다고 가정한다. 풍선을 달기 위해 이동해야하는 거리는 팀이 A와 B로부터 떨어진 거리와 같다. 풍선을 달아주는 사람은 한 번에 풍선 하나만 들고 이동할 수 있다.

### 입력

입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 팀의 수 N(1 ≤ N ≤ 1,000)과 방 A와 B에 보관되어있는 풍선의 수 A, B가 주어진다. (0 ≤ A, B ≤ 10,000) 

다음 N개 줄에는 팀에게 달아줘야하는 풍선의 수 K와 방 A로부터 떨어진 거리 DA, B로부터 떨어진 거리 DB (0 ≤ DA, DB ≤ 1,000)가 주어진다. 풍선이 부족한 경우는 없다. 즉, Σi Ki ≤ A+B.

입력의 마지막 줄에는 0이 세 개 주어진다.

### 출력

각 테스트 케이스에 대해서, 모든 팀에게 풍선을 달아주기 위해 필요한 이동 거리의 최솟값을 한 줄에 하나씩 출력한다. 이때, 풍선을 달아주고 방 A나 B로 돌아오는 거리는 포함하지 않는다. 즉, 방 A와 B에서 팀으로 이동하는 거리만 포함한다.

---

### _풀이_

**그리디, 정렬**

모든 팀에 가장 가까운 방에서 풍선을 조달해주면 좋겠지만 각 방에 있는 풍선의 수가 제한되어 있기 때문에 그리디한 접근방식이 필요하다.

각 팀이 가까운 방에서 풍선을 가져올지 먼 방에서 풍선을 가져올지 정할 방법이 필요한데, **가까운 방을 포기하고 먼 방을 선택했을 때 손해보는 거리가 큰 팀부터 가까운 방에서 풍선을 조달해 줘야 한다.**

즉 (먼 방의 거리 - 가까운 방의 거리)의 값을 기준으로 팀들을 내림차순으로 정렬한 후에 순차적으로 가까운 방에서 풍선을 조달해준 후 만약 가까운 방에 풍선이 없는 경우에는 먼 방에서 풍선을 가져다 주면 최적의 해를 구할 수 있다.
```c++

bool cmp(tuple<int, int, int, int, int>& a, tuple<int, int, int, int, int>& b) {
    int a1, a2, a3, a4, a5, b1, b2, b3, b4, b5;
    tie(a1, a2, a3, a4, a5) = a;
    tie(b1, b2, b3, b4, b5) = b;
    return a1 > b1;
}

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    while (1) {
        int n, a, b;
        int arr[2];
        vector<tuple<int, int, int, int, int>> v;
        cin >> n >> a >> b;
        arr[0] = a;
        arr[1] = b;
        if (n == 0 && a == 0 && b == 0) break;
        
        for (int i = 0; i < n; i++) {
            int k, l, r;
            cin >> k >> l >> r;
            int ab = l >= r ? 1 : 0;
            v.push_back({abs(l-r), max(l,r), min(l,r), k , ab});
        }
        
        sort(v.begin(), v.end(), cmp);
        int dist = 0;

        for (auto [p, maxi, mini, m, ab] : v) {
            if (arr[ab] >= m) {
                dist += (mini * m);
                arr[ab] -= m;
            }
            else {
                int a = arr[ab];
                int b = m - arr[ab];

                dist += (mini * a);
                arr[ab] -= a;

                dist += (maxi * b);
                arr[!ab] -= b;
            }
        }

        cout << dist <<'\n';

    }
    
}

```
