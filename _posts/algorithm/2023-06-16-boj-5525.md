---
title: "BOJ 5525 IOIOI C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 5525 IOIOI C++

문제

> N+1개의 I와 N개의 O로 이루어져 있으면, I와 O이 교대로 나오는 문자열을 PN이라고 한다.  
> P1 IOI
> P2 IOIOI
> P3 IOIOIOI
> PN IOIOI...OI (O가 N개)
> I와 O로만 이루어진 문자열 S와 정수 N이 주어졌을 때, S안에 PN이 몇 군데 포함되어 있는지 구하는 프로그램을 작성하시오.

입력

> 첫째 줄에 N이 주어진다. 둘째 줄에는 S의 길이 M이 주어지며, 셋째 줄에 S가 주어진다.

- 1 ≤ N ≤ 1,000,000
- 2N+1 ≤ M ≤ 1,000,000
- S는 I와 O로만 이루어져 있다.

출력

> S에 PN이 몇 군데 포함되어 있는지 출력한다.

서브테스크

> 50점: N ≤ 100, M ≤ 10 000.
> 50점: 추가적인 제약 조건이 없다.

---

_풀이_

가장 먼저 떠오르는 방법은 문자열 S를 훑으면서 순서대로 P를 탐색하는 것이다.
그러나 이 방법은 50점 밖에 받지 못하고 시간초과를 받았다.
따라서 시간을 줄일 필요가 있는데 풀이법은 다음과 같다.

1. S문자열을 훑으면서 문자가 I인 인데스 st를 찾는다.
2. st이후에 오는 문자가 "OI"임을 체크하고 아니라면 1번으로 되돌아간다.
3. 다음 문자열이 "OI"라면 k값을 1 증가시키고 st를 2 증가시킨다.
4. k값이 n과 같아졌다면 문자열 S에서 p를 찾은것이다. 따라서 cnt값을 1 증가시킨다.
   > 여기까지 탐색한 다음 지금까지의 탐색과정을 이용해서 시간복잡도를 줄인다.
5. 동시에 k값도 1줄인 후에 3번의 st를 2 증가시키는 과정으로 돌아간다.

투포인터와 유사한 기법을 사용하여 시간복잡도를 줄일 수 있었다.
문자열 s에서 p를 찾았을때 만약 바로 직후에 "OI"가 붙어있다면 새로 탐색을 할 필요 없이 시작 인덱스와 끝 인덱스를 조절함으로써 문자열 p를 탐색하는 과정이었다.

코드가 길지 않으므로 이해하는데 어렵지 않았다.

```c++

string p;
string s;
int n, m;

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        p += "IO";
    }
    p += "I";
    cin >> s;
    int cnt = 0;
    for (int st = 0; st < m; st++) {
        if (s[st] == 'O')continue;
        int k = 0;
        while (s[st + 1] == 'O' && s[st + 2] == 'I') {
            k++;
            if (k == n) {
                cnt++;
                k--;
            }
            st += 2;
        }
    }

    cout << cnt;
}

```
