---
title: "BOJ 1520 내리막 길 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 1520 내리막 길 C++

문제

> 여행을 떠난 세준이는 지도를 하나 구하였다. 이 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다.

![1](https://upload.acmicpc.net/0e11f3db-35d2-4b01-9aa0-9a39252f05be/-/preview/)

> 현재 제일 왼쪽 위 칸이 나타내는 지점에 있는 세준이는 제일 오른쪽 아래 칸이 나타내는 지점으로 가려고 한다. 그런데 가능한 힘을 적게 들이고 싶어 항상 높이가 더 낮은 지점으로만 이동하여 목표 지점까지 가고자 한다. 위와 같은 지도에서는 다음과 같은 세 가지 경로가 가능하다.

![2](https://upload.acmicpc.net/917d0418-35db-4081-9f62-69a2cc78721e/-/preview/)

> 지도가 주어질 때 이와 같이 제일 왼쪽 위 지점에서 출발하여 제일 오른쪽 아래 지점까지 항상 내리막길로만 이동하는 경로의 개수를 구하는 프로그램을 작성하시오.

입력

> 첫째 줄에는 지도의 세로의 크기 M과 가로의 크기 N이 빈칸을 사이에 두고 주어진다. 이어 다음 M개 줄에 걸쳐 한 줄에 N개씩 위에서부터 차례로 각 지점의 높이가 빈 칸을 사이에 두고 주어진다. M과 N은 각각 500이하의 자연수이고, 각 지점의 높이는 10000이하의 자연수이다.

출력

> 첫째 줄에 이동 가능한 경로의 수 H를 출력한다. 모든 입력에 대하여 H는 10억 이하의 음이 아닌 정수이다.

---

_풀이_

DFS와 DP를 사용해서 해결할 수 있는 문제였다.

단순 DFS로만 풀이하려 하면 중복된 칸에 대한 처리가 불가능하여 시간 초과를 받는다.

DP테이블의 의미는 다음과 같다.
DP[i][j] = n >> i,j 칸에서 종점까지 갈 수 있는 경우의 수는 n가지이다.

dfs를 통해서 목적지에 도달하면 1을 return 해주면서 이전에 밟았던 경로들은 해당값을 dp테이블에 + 해줌과 동시에 vis테이블을 사용하여 이미 방문한 칸임을 표시한다.

만약 다음번에 같은 칸을 방문한다면 dp테이블에 있는 값을 반환해줌으로써 중복 계산을 줄일 수 있고 시간초과를 해결할 수 있다.

```c++

int n, m, ans;
int board[505][505];
int dp[505][505];
int vis[505][505];

int dfs(int y, int x) {
    if (y == n - 1 && x == m - 1) {
        return 1;
    }
    if (vis[y][x]) return dp[y][x];
    vis[y][x] = 1;
    for (int dir = 0; dir < 4; dir++) {
        int ny = y + dy[dir];
        int nx = x + dx[dir];
        if (nx < 0 || nx >= m || ny < 0 || ny >= n) continue;
        if (board[ny][nx] >= board[y][x]) continue;
        dp[y][x] += dfs(ny, nx);
    }
    return dp[y][x];
}

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> board[i][j];
        }
    }
    cout << dfs(0, 0);
}

```
