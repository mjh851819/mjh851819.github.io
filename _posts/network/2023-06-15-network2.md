---
title: "네트워크 3-2 전송 계층: TCP의 Reliable Data Tranfer"

categories:
  - Network
tags:
  - Network
---

> 이 글은 KOCW에서 제공하는 한양대학교 이석복 교수님의 컴퓨터 네트워크 강의를 기반으로 내용을 정리하고 복습하기 위한 용도로 작성되었습니다.

## TCP

#### 1. TCP Segment Structure

---

![3-4](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/c10577be-1b2d-478b-9f41-388b9d673fbf)

- port 번호: 디/멀티플렉싱을 할때 사용하는 포트번호.
- sequence number, acknowledgement number : 데이터를 주고받을때 사용하는 시퀀스 번호, 데이터를 서로 주고받는 구조이므로(서로가 서로에게 송/수신자) 두개가 필요하다.
  - tcp에서 각 전송계층은 2개의 버퍼를 가지고있다(send buffer, recv buffer). 애플리케이션에서 내려온 데이터가 세그먼트형태로 샌드버퍼에서 상대 리시브 버퍼로 들어간다.
  - receive buffer에 도착한 세그먼트는 해당하는 포트번호의 소켓으로 따라 올라감. 이때 tcp의 in order data의 특성을 지키기 위해서 버퍼에 들어온 데이터들은 sequence number를 참고하여 순서대로 애플리케이션 계층으로 올려보내진다.
  - sendbuffer의 역할은 데이터가 잘 전달되었다는 ACKs 피드백이 오면(시퀀스 넘버를 참고해서) 해당 데이터를 샌드버퍼에서 없애고 오류가 생겼다고 판단되면 해당 sendbuffer에 저장된 데이터를 다시 재전송한다.
- checksum: error ditecting을 위한 필드.
- receive window: 단순하게 말하면 수신자의 receive buffer의 남은 공간을 해당 변수값을 통해 보고함으로써 전송을 조절할 수 있게 해줌(flow control)
  > 그 외 등등은 이후 자연스럽게 알 수 있다.

#### 2. TCP 연결을 더 디테일하게

> 아래의 내용들을 확실히 이해해야 tcp의 연결과 통신을 정확히 이해할 수 있다.

##### 2-1. sequence number

---

- 알기쉽게 말하면 하나의 데이터가 여러개로 쪼개져서 하나의 배열에 들어간다고 했을때의 인덱스 번호로 이해하면 된다.
- 10의 용량을 가진 데이터가 3의 용량의 세그먼트에 담겨서 전달된다고 가정하면, 가장 처음 담기는 데이터의 조각 1~3의 시퀀스 번호는 1이고(가장 앞번호), 그다음은 4~6이므로 4이다.

##### 2-2. acknowlegement number [ACK#n]

---

- ACK#n(시퀸스 번호)은 위의 데이터 번호에서 "나는 n번 데이터 전까지 하나도 빠짐없이 잘 전달 받았다" 는 의미이다.

##### 2-3. window size

---

- tcp는 *pipeline방식*으로 데이터를 한번에 쭉 보낸다고 언급했다. 이때 무차별적으로 데이터를 쏟아내는것이 아니라 window size라는 일정 용량만큼은 다음 ACK응답이 오기 전까지 한번에 보낼 수 있는것이다.
- 일정 윈도우 크기만큼 데이터를 한번에 보냈다면 정상 피드백이 오기 전까지 샌드 버퍼에 담아둬야한다 (재전송의 가능성이 있으므로), 이후 ACK#10 처럼 피드백이 온다면 해당 윈도우를 옆으로 슬라이드해서 옮김으로써 다음 데이터를 보낼 수 있다.

##### 2-4. Loss시 타이머 설정

---

- 타이머값을 너무 작게 잡으면? 실제로 유실이 되지 않았고 그저 응답이 느릴뿐인데도 재전송이 자주 이뤄진다
- 너무 크면? 실제 로스가 일어나고 재전송까지의 시간이 오래걸린다.
- 이상적으로 생각했을때 이상적인 타이머 값은 RTT(데이터가 보내지고 응답이 오는데까지의 시간)보다 조금 더 크게 잡으면 된다.
- 따라서 응답을 주고받을때마다 RTT를 측정하는데 이 값은 들쭉날쭉하다 (큐잉 딜레이의 원인이 가장 크다).
- 이러한 일정하지 않은 RTT값에서 적당한 평균값을 얻을 수 있고 이 RTT보다 적당히 큰 값으로 설정하면 된다. (과학적인 공식이 있다)

#### 3. 실제 TCP의 tcp reliable transper

---

- tcp sender의 동작: 샌드 버퍼에서 데이터를 전송할때 가장 앞 윈도우에 해당하는 데이터를 보낼때 타이머가 꺼져있다면 그 데이터를 보낸 시간을 기준으로 타이머를 키고 이후의 데이터에 대해서는 타이머를 설정하지 않는다.
- 이후 타이머가 터지면 타이머를 설정한 데이터부터의 세그먼트를 재전송한다.
- 이후 만약 ACK#50의 피드백을 받는다면 51번까지 윈도우의 시작점을 옮기고 50번까지의 데이터를 send buffer에서 비우며 타이머를 51번 기준으로 다시 매핑한다.

![3-5](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/e792a8d8-827d-41ff-962f-af29f30cd1bc)

- A의 첫번째 데이터 전송에 대한 B의 응답이 Loss, 이후 timeout이 터져서 데이터를 재전송하는 과정이다.

![3-6](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/54b02e27-2d13-4a54-8ef6-32459f03f076)

- 두번의 데이터전송에서 Seq num = 120 까지의 데이터를 보냈으나 네트워크 문제로 응답의 도착이 늦어져 A에서 타임아웃이 터졌다.
- A는 로직대로 데이터가 전달되지 않았다고 판단하여 재전송을 했으나 B에선 seq num로 이미 받은 재전송 데이터임을 판단할 수 있으므로 정상 흐름으로 되돌아간다.

![3-7](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/b6c8934f-87c7-43ea-9f3b-8fe98f4603e7)

- A는 pipeline 프로토콜로 2개의 데이터를 거의 동시에 보냈고 B는 각각의 데이터를 잘 받아 두개의 응답을 보냈으나 첫번재 응답이 Loss됐다.
- 그러나 두번째 응답에서 ACK#120의 의미는 Seq num = 120까지의 데이터를 모두 잘 전달 받았다는 의미이므로 이후 정상흐름으로 돌아간다.
