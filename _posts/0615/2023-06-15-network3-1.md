---
title: "네트워크 3-1 전송 계층: 전송 계층의 개념 "

categories:
  - Network
tags:
  - Network
---

> 이 글은 KOCW에서 제공하는 한양대학교 이석복 교수님의 컴퓨터 네트워크 강의를 기반으로 내용을 정리하고 복습하기 위한 용도로 작성되었습니다.

> 이번 챕터에서는 전송 계층(Transfer layer)에 대해서 설명한다. 이전까지 배운 애플리케이션 계층에서 가장 중요한 부분은 http와 DNS였다. 이 두가지 모두 어떤 프로세스가 다른 프로세스와 통신하는 것이며 이러한 프로세스의 개발은 os가 제공하는 기능인 TCP와 UDP 두가지 중 하나를 사용해서 만들어진다. 전송계층 단원에서는 이러한 tcp, udp에 대해서 더욱 자세히 알아본다.

## 전송 계층의 개념과 역할

#### 1. 전송 계층의 개념과 구성

---

- transport layer는 간단히 설명하면 애플리케이션 계층에서 메세지를 받아서 다른 목적지 애플리케이션 계층으로 전송하는 계층이다.
  > transport layer 의 개념에 대해 이야기할때 하위 계층인 network계층에 대한 이야기는 하지않는다.(생략)
- 사용자 계층에서 만들어진 데이터의 단위를 메세지라고 표현한다.
- 메세지는 전송 계층으로 내려가서 segment라는 전송 단위의 DATA영역에 들어간다. 세그먼트는 메타데이터인 HEAD와 데이터의 모음인 DATA로 이루어져있다.  
  ![3-1](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/355f9295-e805-46f9-b2b1-a1b00ce5ac72)
  > 세그먼트의 구조, 이후 네트워크 계층으로 내려가면 패킷이라는 전송단위 내부로 들어간다.

#### 2. tcp와 udp의 특징

---

- **TCP**

1.  Reliable (데이터가 전송됨을 반드시 보장함)
2.  In-order-delivery
3.  Flow Cotroll (수신자의 수신역량에 따라 송신을 조절함)
4.  Congestion Control (네트워크 상태에 따라 송신을 조절함)
    > 앞으로 3단원에서 배우게 될 주요 주제들이다.

- **UDP**

1.  Unreliable
2.  Un-order-delivery
    > 제공하는 기능이 거의 없다고 생각하면 된다.

- delay guarantees와 bandwidth guarantees등 부가적인 기능은 제공하지 않는다.이러한 부가기능은 애플리케이션 계층에서 직접 구현해야한다.

#### 3. Multiflexing과 Demultiplexing

---

- 머신 내부에는 여러 프로세스가 있고 프로세스가 네트워크를 사용한다면 각자의 소켓을 가지고 있다.
- 이때 애플리케이션 계층에 있는 수많은 소켓에서 전송 계층까지 데이터는 하나의 통로(이더넷, wifi )로 내려온다
- 이렇게 여러 데이터가 하나의 길로 내려오는것을 **Multiflexing**이라고 한다.
- **DeMultiflexing**은 반대로 하나의 통로에서 올라온 데이터를 여러 플로세스의 소켓으로 분산시켜주는것이다.

- _왜 전송계층이냐?_
- 전송 계층이 소켓 인터페이스(tcp, udp)를 직접적으로 다루는 계층이기 때문이다.
- Multiflexing은 sender에서 Demultiflexing은 receiver에서 이루어진다.
- 이때 Demultiflexing 플렉싱 과정에서 하나의 통로로 들어온 데이터들을 알맞은 프로세스의 소켓에 뿌려줘야 하는데 이때 필요한 것이 *포트번호*이다.
  > ip주소는 어떤 머신에 갈것인지 필요한 주소고 포트넘버가 어떤 소켓에 갈건지에 필요. 이러한 포트번호는 세그먼트의 헤더 최상단에 위치한다.

#### 4. udp와 tcp에서의 DeMultiflexing 차이

---

> tcp와 udp는 각각 어떤식으로 DeMultiflexing할까? => 어떤식으로 세그먼트를 알맞은 소켓에 뿌려줄까?

- udp의 경우 receiver는 전달받은 세그먼트의 dest port만을 가지고 인덱싱을 하여 목적지 소켓을 찾는다.
- 따라서 수많은 프로세스에서 같은 dest port로 세그먼트를 보낼 때 모두 같은 소켓으로 데이터가 들어온다.
- tcp의 경우는 source ip address, port num 그리고 dest ip add, port num 4가지를 인덱싱하여 목적지 소켓을 찾는다
- 따라서 여러 프로세스에서 같은 목적지 ip의 같은 포트번호로 데이터를 보내도 소스 ip와 포트번호가 다르면 각자 다른 소켓에 데이터가 전달된다.

  > 따라서 tcp 는 어떤 머신에서 접속하든 1:1 대응이다(이를 point-to-point 라고 표현한다). 실제로는 서버측에서 이런식으로 여러 소켓을 준비해 놓지는 않고 각각의 데이터마다 스레드 서버를 생성해서 대응한다.

- 아래의 그림에서 p1,p2,p3는 각각 같은 dest ip와 dest port로 데이터를 보내지만 리시버인 p4는 각각 다른 소켓으로 Demulitflexing해주면서 각각의 소켓을 1대1 대응시켜주는 모습을 볼 수 있다.
  ![3-2](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/d419e01f-8cb9-4643-940d-39bdc92e23fb)

> 따라서 tcp 는 어떤 머신에서 접속하든 소켓상 1:1 대응이다. 실제로는 서버측에서 이런식으로 여러 소켓을 준비해 놓지는 않고 각각의 데이터마다 스레드 서버를 생성해서 대응한다.

## UDP

> UDP는 간단한 프로토콜로 알아볼 부분도 굉장히 적다.

#### 1. UDP란?

---

- udp를 아무 기능도 제공하지 않는다고는 했지만 사실 위에서 알아봤듯이 _De/Multiflexing_ 기능은 제공한다.
- 스트리밍 서비스, Dns, SMTP 등의 사용자계층 프로세스는 udp를 사용한다.
- udp 헤더 4개의 필드[source port, dest port, length, checksum]
  ![3-3](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/93bc034b-de84-420b-8d23-7b92f6a1d518)
- De/Multiflexing 위한 포트번호, 길이, 데이터 전송 중간에 에러가 있었는지 체크하는 checksum 변수가 있다.
- 즉 DeMultiflexing 과정에서 checksum변수를 확인해서 데이터에 에러가 있다면 애플리케이션 계층으로 데이터를 올려 보내지 않는다.
- 따라서 udp는 최소한 _에러가 담긴 메세지는 애플리케이션 계층으로 전달하지 않는다._

## TCP 미리 알아보기

> tcp의 특성에 따라서 다른 프로세스로 데이터를 보낼 때 그 데이터가 반드시 전달됨을 전송계층에서 보장받는다. 하지만 전송계층 아래의 계층은 전혀 reliable 하지않다. (패킷 로스, 전송 에러) 즉, 전송 계층의 tcp 방식이 어떻게든 이러한 오류를 처리해서 사용자 입장에서 reliable data tranfer를 느낄 수 있게 해주는것이다.

#### RDT 토이 프로젝트

- tcp의 reliable data transfer를 간단히 구현한 프로젝트, 송신자는 데이터를 보내고 그 데이터를 받았다는 응답이 오기 전까지는 다음 데이터를 보내지 않는 간단한 tcp 모의 프로젝트.

#### 1. rdt 1.0[패킷유실 없음, 패킷에러 없음]

---

- 데이터를 전달하고 응답을 받는 것 외에 특별한 기능은 없다.

#### 2. rdt 2.0[패킷유실 없음, _패킷에러 가능_]

---

- 데이터가 잘 전달되었는지 *피드백*을 해준다(ACKs, NAKs 사용).
- 이러한 피드백이 가능하려면 데이터에 에러가 있는지 판독할 수 있어야한다. (_error ditection_) checksum변수로 가능하다.

**_error ditection, feedback, retransmission_ 3가지 기능이 추가된다.**

#### 3. rdt 2.1[패킷유실 없음, _패킷에러 가능 + a_]

---

> 코너 케이스: 만약 피드백에 에러가 있다면?? (acks, naks 판단이 안될때)

**sequence number의 도입**

- 송신자 입장에서는 피드백에 문제가 생겨 ACKs로 판단할 수 없다면 반드시 재전송을 한다.
- 하지만 수신자 입장에서 만약 손실된 피드백이 acks였다면 재전송 되어 들어온 데이터가 중복된 데이터인지, 새로운 데이터인지 판단할 근거가 없다.
- 따라서 데이터를 보낼때 재전송된 데이터인지 아닌지 판단할 근거가 필요한데 그것이 바로 sequence number다.
- 모든 패킷마다 sequence number가 붙어있어서 리시버가 이미 받은 데이터로 판단하고 해당 데이터를 무시할지 받을지 판단할 수 있다.

#### 4. rdt 2.2[패킷유실 없음, _패킷에러 가능 + a_]

---

**ACKs만 사용해서 구현**

- sequence number와 ACKs만을 사용해서 기능을 구현할 수 있다.
- 리시버는 피드백을 보낼때 자신이 가장 마지막에 받은 sequence number와 ACKs만을 보낸다면 송신자는 마지막으로 보낸 데이터의 sequence number의 ACKs가
  넘어오는지 확인함으로써 데이터가 정상적으로 전달되었는지 확인할 수 있다.

> 다음 단원에서 sqeunce number와 tcp의 reliable data transfer에 대해서 더욱 자세히 알아본다.

#### 5. rdt 3.0[_에러 가능_, 패킷로스 가능]

---

**피드백에 대한 타이머를 설정하고 일정시간 응답을 기다리며 데이터가 유실되었는지 판단**

- 타이머의 값은 어떻게 설정할까? 정해진 답은 없다 항상 최적의 시간을 정해서 타이머를 설정해야 한다.
