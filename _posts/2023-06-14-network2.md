---
title: "네트워크 2-1 애플리케이션 계층: HTTP와 WEB"

categories:
  - Network
tags:
  - Network
---

> 이 글은 KOCW에서 제공하는 한양대학교 이석복 교수님의 컴퓨터 네트워크 강의를 기반으로 내용을 정리하고 복습하기 위한 용도로 작성되었습니다.

> 이번 챕터에서는 애플리케이션 계층에 대해서 설명한다. 큰 단원으로는 소켓 프로그래밍(tcp, udp), smtp, dns의 3챕터로 이루어져 있다.

## 애플리케이션 계층과 소켓 프로그래밍의 배경

#### 1. 애플리케이션 계층(프로세스와 프로세스간의 통신)

---

- 서버 - 클라이언트 구조에서 서버와 클라이언트는 모두 엄밀히 각각의 프로세스라고 할 수 있고 이러한 프로세스끼리의 통신을 *inter process comunication*이라고 한다.
- 이때 다른 머신에 존재하는 프로세스끼리의 상호작용이 우리가 흔히 알고있는 서버 - 클라이언트 구조의 통신이고 이를 가능할 수 있게 OS에서 제공하는것이 바로 *소켓*이다.
- 쉽게 설명하면 우리가 보내고자 하는 메세지(http메세지)를 편지봉투(소켓)에 넣어서 하위 계층(우채통)에 넣어주면 마법같이 상대편 프로세스에 메세지가 도착해 있다.
  - _해당 강좌는 응용계층부터 링크계층까지 Top-down의 방식으로 설명하기 때문에 아직 배우지 않은 하위계층의 대한 설명은 생략하고 넘어간다. 이후 배울 강의에서 모두 알게될 것._
- 이때 편지봉투에는 받는 상대가 누군지 적어야하는데 그것이 바로 ip주소고 ip주소는 네트워크상에 존재하는 특정 머신의 주소다.
- 하지만 머신의 주소까지만 알아서는 해당 머신의 여러 프로세스 중 어떤 프로세스로 전달되야 하는지 알 방법이 없다.
- 따라서 우리는 종합적으로 소켓에 ip주소와 포트번호를 넣어서 데이터를 전송하고 이를 *소켓 프로그래밍*이라고 한다.

> 우리가 서버 프로세스에 요청(request)하기 위해선 서버ip주소와 서버 프로세스의 포트번호가 필요하다. 각 프로토콜마다 고유의 포트번호가 정해져 있다. 웹서버 프로토콜(프로세스)는 80번을 사용한다.

> 우리가 브라우저에 www.naver.com을 입력하면 DNS를 통해서 ip주소를 알 수 있다. 그 다음 포트번호를 알아야 하는데 웹 통신은 암묵적으로 80번 포트를 사용하기로 정해뒀기 때문에 포트번호를 따로 명시하지 않아도 된다.

> 반면 서버와 다르게 클라이언트가 데이터를 응답받을때는 특정 포트번호 몇개를 제외하면 아무 포트번호나 받아도 상관없다고 한다.

> 이러한 데이터 전달에는 몇가지 기대치가 있는데(데이터가 도착하는 타이밍, 보안 등등...) 현대 웹통신(tcp)에서는 데이터가 전달되는것을 보장하는것 외에는 아무런 기대치도 충족시키지 못하기 때문에 나머지 부가기능들은 우리가 소켓 프로그래밍을 통해서 직접 구현해야 한다.

#### 2. Web과 Http

---

- HTTP(Hipertext Transper protocol): request와 response 두종류만 존재하는 단순한 프로토콜. 상태 또한 존재하지 않음(Stateless).
- 애플리케이션 계층에서 사용되며 tcp를 사용하기 때문에 신뢰성이 보장된다.
- 이때 사용되는 tcp는 두종류가 있는데 영속성http와 비영속성http가 있다.
- 둘의 차이는 tcp 연결이 끝나고 다음 연결을 시도하기 전에 연결을 끊느냐 아니냐에 있다. 영속성 http는 연결을 재사용할 수 있다.

#### 3.영속성http와 비영속성http의 차이

---

> request: www.naver.com/index.html <- 내부에 10개의 추가 요청을 지닌 객체가 존재함.

##### 비 영속성 http(non-persistentHTTP)

1. 우선 three-way-handshake과정에서 한번 데이터를 주고받는다.
2. 두번째에 실제로 데이터를 요청하고 index.html 객체를 받는다.
3. 두번째 요청이 끝나고 tcp연결을 끊기 때문에 이후 10개의 요청에서 매번 tcp연결을 새로 해야함.

##### 영속성 http(persistentHTTP)

1. 우선 three-way-handshake과정에서 한번 데이터를 주고받는다.
2. 두번째에 실제로 데이터를 요청하고 index.html 객체를 받는다.
3. 이후 10번의 통신이 남아있으나 tcp연결을 끊지않고 재사용하여 10번의 tcp연결에 소요되는 시간이 줄어듬.

- 여기서 더욱 개선하자면 pipeline방식을 이용해서 10개의 request를 한번에 줄지어서 보내고 response도 한번에 받을 수 있음.
  > 이 방식을 이용하면 용량은 같기때문에 10번의 데이터를 주고받을때 걸리는 지연시간은 같지만. 물리적인 거리로 인해서 발생하는 지연이 10에서 1로 줄어든다.

#### 4. http 메세지의 종류

---

- request 메세지: 웹 브라우저에서 소캣을 통해 보내는 메세지
- 첫번째줄: http메소드 (공백) url (공백) HTTP 버전 (공백) 으로 이루어짐
- 이후 아래줄에는 헤더와 바디 등 부수적인 정보들이 포함되어 있다.

- response 메세지: 서버에서 클라이언트로 보내는 메세지
- 첫번째줄: http메소드 (공백) 상태 (공백) 번호
- 이후 아래줄에는 부수적인 정보들
- 데이터 (ex. index.html)

#### 5. 쿠키

---

- http는 기본적으로 무상태(stateless)이다. 그러나 상태를 가지는것이 유리한 경우가 생각보다 많다. 이때 등장한것이 _쿠키_.

- 클라이언트가 아마존 서버에 방문하려함.

1.  이전에 아마존에 방문하면서 받은 쿠키가 있는지 확인한다. 없다면 없이 요청한다.
2.  요청을 받은 아마존은 메세지에 쿠키가 없는걸 확인하고 클라이언트의 쿠키를 생성하여 서버 데이터베이스에 저장한다.
3.  서버는 응답 메세지에 쿠키를 넣어서 보낸다. 클라이언트는 아마존 쿠키를 브라우저에 보관한다.
4.  이후 요청에서는 쿠키를 요청메세지에 넣어서 보냄으로써 서버가 클라이언트의 상태를 확인할 수 있다(구매이력 등).
5.  일주일 후 아마존에 방문하면 서버가 이전 구매이력에 따른 추천 항목도 아마존 페이지에 함께 실어서 보낼 수 있다!

#### 6. 웹 캐시(프록시, 프록시 서버)

---

- 사용자와 서버 사이에 존재하며 사용자의 요청을 대신 서버에 전달해주고 서버의 응답 또한 프록시 서버가 먼저 받고 사용자에게 전달해주는 역할을 한다.
- 이 과정에서 응답값을 프록시서버가 저장하고 있다가, 다른 사용자가 같은 데이터를 요청하면 요청이 서버까지 가지않고 프록시 서버가 응답해준다.
- 비용절감 등 다양한 이점덕에 현대 인터넷에서 대부분 사용되고있다.

##### 장점

1.  빠르다, 딜레이가 적다, 종합적으로 사용자가 큰 편의를 가진다.
2.  서버 입장에서도 요청이 적어짐으로써 서버의 부하가 줄어든다.
3.  내부에 프록시 서버를 두면 외부망을 사용하는 빈도가 줄어들어 내부에서 사용하는 인터넷망의 비용을 절감할 수 있다. (chaceHitRate가 높을수록 절감 효과가 크다.)

##### 단점

- 캐시가 등장하면 항상 등장하는 문제는 바로 *일관성*문제다.
- 서버에서 데이터를 최신화했는데 프록시서버는 이를 알 수 있는 방법이 없기때문에 사용자가 잘못된 정보를 응답받을 수 있다.
- 해결법: 프록시 서버에서 conditional변수를 사용해서 서버에 데이터가 변경되었는지를 주기적으로 물어보고 서버는 변경되지 않았다면 변경되지 않았다는 메세지만 보내고, 변경되었다면 데이터를 보냄으로써 일관성 문제를 해소한다.
