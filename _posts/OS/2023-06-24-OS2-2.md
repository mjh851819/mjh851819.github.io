---
title: "운영체제 2: 하드웨어 시스템 구조와 프로그램 실행의 원리 2"

categories:
  - OS
tags:
  - OS
---

> 이 글은 KOCW에서 제공하는 이화여자대학교 반효경 교수님의 운영체제 강의를 기반으로 내용을 정리하고 복습하기 위한 용도로 작성되었습니다.

## 하드웨어 시스템 구조와 프로그램 실행의 원리 2

#### 1. 프로그램 실행의 전체과정 정리

---

1. cpu는 자신의 register인 PC(program counter)가 가르키는 메모리의 주소에 해당하는 명령을 계속해서 수행한다.
2. 수행을 마치면 계속해서 다음 주소에 해당하는 명령을 수행하는데 그 과정 사이에 interrupt line에서 interrupt가 있는지 확인한다.
3. interrupt가 있으면 잠시 작동을 멈추고 OS에게 cpu 제어권이 넘어간다. (modebit이 1 에서 0으로 바뀜)
4. OS는 해당 인터럽트 벡터를 참고해서 해당 인터럽트가 어떤 인터럽트 처리 루틴(시스템 콜)을 수행해야 하는지 찾아본다.
5. 인터럽트의 종류에따라 인터럽트 처리 루틴을 실행하고 다시 cpu작업을 진행한다.

#### 2. 동기식 입출력과 비동기식 입출력

---

- 동기식 입출력: io요청 후 io작업완료까지 대기 후 사용자 프로그램에게 제어가 되돌아오는 것 (다음 행동에 입출력의 결과가 꼭 필요한 경우)
- 구현방법1

1.  io가 끝날때까지 cpu를 낭비시킨다
2.  매 시점 하나의 io만 일어날 수 있다

- 구현방법2

1.  io가 완료될때 까지 해당 프로그램에게서 cpu를 빼앗는다
2.  io처리를 기다리는 줄에 그 프로그램을 줄세운다
3.  다른 프로그램에게 cpu자원을 준다

- 비 동기식 입출력: io가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에게 넘어오는 것 (다음 행동이 입출력에 영향을 받지 않음)

#### 3. 저장장치 계층구조

---

![10-9](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/582bf153-7b5d-4848-a74b-28dd3d98dd5a)

- 위로갈수록 속도가 빠르며 단위공간당 비용이 비싸서 용량이 적다
- 아래쪽은 비 휘발성, 위쪽은 휘발성 저장매체다.
- 또한 cpu에서 바로 접근이 가능한 저장매체를 primary(Executable)하다고 표현한다.
- cpu가 직접 접근하기 위해선 main memory처럼 byte단위로 주소를 매겨서
  byte단위 접근이 가능해야한다.
- 즉 그자리에서 직접 데이터를 읽을 수 있어야한다.

- 위로갈수록 비용이 비싸기때문에 용량이 적지만 속도가 빠르다.
- cpu가 메모리에서 데이터를 읽기 위해선 비교적 많은 시간이 걸리기때문에 register와 memory 사이에 cache계층이 등장했다.
- 이처럼 자주 사용할 것이라 예측되는 데이터를 비교적 빠른 저장공간에 copying해 놓는것을 caching이라고 한다.

#### 4. 프로그램의 실행

---

- 프로그램이 실행되는 과정에 대해 알아보자.

![10-10](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/cc3bf081-417c-4a54-a273-2605ee57c081)

- 프로그램은 실행 '파일'의 형태로 file system에 저장되어있다.
- 이런 실행파일을 실행시키면 프로세스가 되어 메모리에 올라가게된다.
- 정확히는 실제 메모리에 올라가기 전에 '가상 메모리'라는 공간에 먼저 올라가게 된다.
- 가상 메모리는 각 프로그램마다 독자적으로 가지는 주소공간이다.
- 프로그램마다 stack, data, code의 가상메모리 영역이 할당되는데 이러한 메모리 전체가 한번에 메인 메모리에 올라가면 메모리가 낭비된다.
- 따라서 가상메모리에서 당장 사용할 부분만 메인 메모리에 올라가고 이외의 부분은 swap area에 따로 보관해둔다.
- 이때 가상메모리에서 실제 메모리로 올라갈때 하드웨어의 도움을 받아 주소가 변환되어서 메인 메모리에 올라간다.

#### 5. 커널 주소 공간의 내용

---

- 위에 말한 메인 메모리에는 기본적으로 운영체제(커널)이 가장 먼저 올라가있다. - 해당 커널 주소공간의 내용에 대해 살펴보자

![10-11](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/ec4aa295-faae-4247-8c04-63d0a16ba2f1)

- 모든 주소공간은 code, data, stack의 영역으로 나누어져 있다.
- 다음은 운영체제 각 영역의 내용이다
- code : 시스템 콜, 인터럽트 처리코드, 자원 관리를 위한 코드, 서비스 코드
- data: 운영체제가 사용하는 여러가지 자료구조들. cpu, memory나 프로세스를 관리하기 위한 테이블에 대한 자료구조들이다.
- stack: 함수를 호출하거나 return할때 사용되는 stack영역

#### 6. 사용자 프로그램이 사용하는 함수

---

- 현대의 거의 모든 프로그램은 함수의 구조로 짜여져있다.
- 이런 사용자 프로그램이 사용하는 함수는 3가지 종류가 있다.

1. 사용자 정의 함수: 자신의 프로그램에서 정의한 함수
2. 라이브러리 함수: 자신의 프로그램에서 정의하지 않고 외부에서 가져온 함수. 실행파일 내에 포함되어있다.
   > 위 두가지 함수들은 프로세스의 주소공간 code영역에 들어있다.
3. 커널 함수: 운영체제 프로그램의 함수.
   > 사용자 프로그램에서 작성되어있어도 커널의 주소공간의 code영역에 들어있다.

- 프로세스가 사용자 함수를 호출할때 같은 프로세스의 주소공간 내에서 점프는 가능하지만 커널함수를 호출할때는 커널의 영역으로 점프한다는건 불가능한 이야기다.
- 그렇기 때문에 앞서 사용자함수를 호출하는것과 커널함수를 호출하는것은 다르다고 말한것이다.
