---
title: "BOJ 1956 운동 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 1956 운동 C++

문제

> 사악한 암흑의 군주 이민혁은 드디어 마법 구슬을 손에 넣었고, 그 능력을 실험해보기 위해 근처의 티떱숲에 홍수를 일으키려고 한다. 이 숲에는 고슴도치가 한 마리 살고 있다. 고슴도치는 제일 친한 친구인 비버의 굴로 가능한 빨리 도망가 홍수를 피하려고 한다.

> 티떱숲의 지도는 R행 C열로 이루어져 있다. 비어있는 곳은 '.'로 표시되어 있고, 물이 차있는 지역은 '\*', 돌은 'X'로 표시되어 있다. 비버의 굴은 'D'로, 고슴도치의 위치는 'S'로 나타내어져 있다.

> 매 분마다 고슴도치는 현재 있는 칸과 인접한 네 칸 중 하나로 이동할 수 있다. (위, 아래, 오른쪽, 왼쪽) 물도 매 분마다 비어있는 칸으로 확장한다. 물이 있는 칸과 인접해있는 비어있는 칸(적어도 한 변을 공유)은 물이 차게 된다. 물과 고슴도치는 돌을 통과할 수 없다. 또, 고슴도치는 물로 차있는 구역으로 이동할 수 없고, 물도 비버의 소굴로 이동할 수 없다.

> 티떱숲의 지도가 주어졌을 때, 고슴도치가 안전하게 비버의 굴로 이동하기 위해 필요한 최소 시간을 구하는 프로그램을 작성하시오.

> 고슴도치는 물이 찰 예정인 칸으로 이동할 수 없다. 즉, 다음 시간에 물이 찰 예정인 칸으로 고슴도치는 이동할 수 없다. 이동할 수 있으면 고슴도치가 물에 빠지기 때문이다.

입력

> 첫째 줄에 50보다 작거나 같은 자연수 R과 C가 주어진다.

> 다음 R개 줄에는 티떱숲의 지도가 주어지며, 문제에서 설명한 문자만 주어진다. 'D'와 'S'는 하나씩만 주어진다.

출력

> 첫째 줄에 고슴도치가 비버의 굴로 이동할 수 있는 가장 빠른 시간을 출력한다. 만약, 안전하게 비버의 굴로 이동할 수 없다면, "KAKTUS"를 출력한다.

---

_풀이_

BFS에서 물과 고슴도치 두가지 상태를 모두 관리해줘야 해결이 가능한 문제였다.

우선 핵심 풀이법은 물에 대한 좌표를 먼저 q에 넣고 그 다음 고슴도치의 좌표를 q에 넣어줘야 한다.

q는 먼저 들어간 순서대로 원소가 나오므로 위 방법으로 q에 원소를 넣어줘야만 고슴도치가 물에 잠기는 상황이 발생하지 않고 BFS를 진행할 수 있다.

q는 {y좌표, x좌표, 고슴도치인지 물인지를 표시하는 문자}의 tuple이 들어간다.
즉 q에서 원소를 꺼낸 후 고슴도치의 경우와 물의 경우를 각각 관리한다.

물과 고슴도치는 우선 공통과정을 거친다.

1. q에서 꺼내진 후 좌, 우, 상, 하 다음칸에 대하여 유효한 좌표값인지 검사한다.
2. 다음칸에 돌이있거나 물이 있다면 더이상 진행하지 않는다.

여기까지 물과 고슴도치가 공통으로 진행한 후 고슴도치의 경우는

1. 이미 방문한 칸이라면 더이상 진행하지 않는다.
2. 처음 방문한 칸이라면 dist배열에 1늘어난 거리를 적어준다.
3. 다음 좌표값을 q에 넣는다.

물의 경우는 다음과 같다.

1. 다음칸이 비버굴이라면 더이상 진행하지 않는다.
2. 비버굴이 아니라면 board에서 다음칸을 물이 있는칸으로 수정한다.
3. 다음 좌표값을 q에 넣는다.

모든 과정이 끝난 후 dist배열을 통해서 비버굴까지의 시간을 알 수 있다.

```c++

string board[55];
int n, m;
int dist[55][55];

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m;

    queue<tuple<int, int, char>> q;
    pair<int, int> st, en;
    for (int i = 0; i < n; i++) {
        cin >> board[i];
        for (int j = 0; j < m; j++) {
            if (board[i][j] == 'S') {
                st = { i,j };
                board[i][j] = '.';
            }
            if (board[i][j] == '*') {
                q.push({ i,j, '*'});
            }
            if (board[i][j] == 'D') en = { i,j };
        }
    }

    for (int i = 0; i < n; i++) {
        fill(dist[i], dist[i] + m, -1);
    }

    q.push({st.Y, st.X, 'S'});
    dist[st.Y][st.X] = 0;

    while (!q.empty()) {
        int y, x, c;
        tie(y, x, c) = q.front(); q.pop();
        for (int dir = 0; dir < 4; dir++) {
            int ny = y + dy[dir];
            int nx = x + dx[dir];
            if (nx < 0 || nx >= m || ny < 0 || ny >= n) continue;
            if (board[ny][nx] == 'X' || board[ny][nx] == '*') continue;
            if (c == 'S') {
                if (dist[ny][nx] != -1) continue;
                dist[ny][nx] = dist[y][x] + 1;
                q.push({ ny,nx, 'S'});
            }
            else if (c == '*') {
                if (board[ny][nx] == 'D') continue;
                board[ny][nx] = '*';
                q.push({ ny,nx, '*'});
            }
        }
    }

    if (dist[en.Y][en.X] == -1) cout << "KAKTUS";
    else cout << dist[en.Y][en.X];


}


```
