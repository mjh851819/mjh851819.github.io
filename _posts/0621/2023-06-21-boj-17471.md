---
title: "BOJ 17471 게리맨더링 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 17471 게리맨더링 C++

문제

> 백준시의 시장 최백준은 지난 몇 년간 게리맨더링을 통해서 자신의 당에게 유리하게 선거구를 획정했다. 견제할 권력이 없어진 최백준은 권력을 매우 부당하게 행사했고, 심지어는 시의 이름도 백준시로 변경했다. 이번 선거에서는 최대한 공평하게 선거구를 획정하려고 한다.

> 백준시는 N개의 구역으로 나누어져 있고, 구역은 1번부터 N번까지 번호가 매겨져 있다. 구역을 두 개의 선거구로 나눠야 하고, 각 구역은 두 선거구 중 하나에 포함되어야 한다. 선거구는 구역을 적어도 하나 포함해야 하고, 한 선거구에 포함되어 있는 구역은 모두 연결되어 있어야 한다. 구역 A에서 인접한 구역을 통해서 구역 B로 갈 수 있을 때, 두 구역은 연결되어 있다고 한다. 중간에 통하는 인접한 구역은 0개 이상이어야 하고, 모두 같은 선거구에 포함된 구역이어야 한다.

> 공평하게 선거구를 나누기 위해 두 선거구에 포함된 인구의 차이를 최소로 하려고 한다. 백준시의 정보가 주어졌을 때, 인구 차이의 최솟값을 구해보자.

입력

> 첫째 줄에 구역의 개수 N이 주어진다. 둘째 줄에 구역의 인구가 1번 구역부터 N번 구역까지 순서대로 주어진다. 인구는 공백으로 구분되어져 있다.

> 셋째 줄부터 N개의 줄에 각 구역과 인접한 구역의 정보가 주어진다. 각 정보의 첫 번째 정수는 그 구역과 인접한 구역의 수이고, 이후 인접한 구역의 번호가 주어진다. 모든 값은 정수로 구분되어져 있다.

> 구역 A가 구역 B와 인접하면 구역 B도 구역 A와 인접하다. 인접한 구역이 없을 수도 있다.

1. 2 ≤ N ≤ 10
2. 1 ≤ 구역의 인구 수 ≤ 100

출력

> 첫째 줄에 백준시를 두 선거구로 나누었을 때, 두 선거구의 인구 차이의 최솟값을 출력한다. 두 선거구로 나눌 수 없는 경우에는 -1을 출력한다.

---

_풀이_

그래프에서의 BFS를 활용한 시뮬레이션 문제였다.

전체적인 과정은 다음과 같다.

1. 간선을 신경쓰지 않고 모든 선거구의 경우의 수를 고려한다.
2. 각 선거구가 나누어질 수 있는 선거구인지 체크한다.
3. 나누어질 수 있는 선거구라면 인구수 차이를 계산해서 최솟값인지 아닌지 판단한다.

1번 과정은 next_permutation과 do-while문을 사용해서 간단하게 구현했다.
2번 과정의 선거구가 나누어질 수 있는 선거구인지 판단하는 과정은 다음과 같다.

1. 초기 데이터를 입력받을때 모든 간선을 리스트의 형태로 저장해 놓는다.
2. 각 선거구의 경우의 수를 나눌때 arr배열로 나뉘는데, arr배열의 인덱스가 도시의 번호이며 arr의 값이 0이냐 1이냐에 따라 두 선거구로 나뉜다.
3. 각 선거구의 경우의 수 마다 bfs알고리즘을 돌리되 같은 선거구가 아닌 경우에는 q에 push하지 않는식으로 구현한다. 즉, 같은 선거구이면서 그래프상으로 인접해 있어야지만 진행할 수 있다.
4. 해당 과정으로 번호를 부여해가며 구역을 나눈다.

위 과정에서 산출된 구역번호를 기준으로 가능한 경우의 수인지 판단할 수 있었다.

```c++

vector<int> adj[11];
int sc[11];
int n;


int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> sc[i];
    }
    for (int i = 1; i <= n; i++) {
        int m;
        cin >> m;
        for (int j = 0; j < m; j++) {
            int v;
            cin >> v;
            adj[i].push_back(v);
            adj[v].push_back(i);
        }
    }
    int mini = INF;
    for (int i = 1; i < n; i++) {
        int arr[11] = {1,1,1,1,1,1,1,1,1,1,1};
        for (int j = 1; j <= i; j++) {
            arr[j] = 0;
        }
        do {
            int vis[11];
            fill(vis, vis + n + 1, 0);
            int area = 1;
            for (int i = 1; i <= n; i++) {
                if (vis[i] != 0) continue;
                queue<int> q;
                q.push(i);
                vis[i] = area;
                while (!q.empty()) {
                    auto cur = q.front(); q.pop();
                    for (auto nxt : adj[cur]) {
                        if (vis[nxt] != 0) continue;
                        if (arr[nxt] != arr[cur]) continue;
                        vis[nxt] = area;
                        q.push(nxt);
                    }
                }
                area++;
            }

            bool flag = 0;

            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    if (arr[i] == arr[j]) {
                        if (vis[i] != vis[j]) flag = 1;
                    }
                }
            }

            if (flag) continue;
            int p0 = 0, p1 = 0;
            for (int i = 1; i <= n; i++) {
                if (arr[i] == 1) p1 += sc[i];
                else p0 += sc[i];
            }

            mini = min(mini, abs(p0 - p1));


        } while (next_permutation(arr + 1, arr + n + 1));

    }
    if (mini == INF) cout << -1;
    else cout << mini;
}


```
