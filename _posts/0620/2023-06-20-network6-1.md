---
title: "네트워크 6-1 무선이동 네트워크"

categories:
  - Network
tags:
  - Network
---

> 이 글은 KOCW에서 제공하는 한양대학교 이석복 교수님의 컴퓨터 네트워크 강의를 기반으로 내용을 정리하고 복습하기 위한 용도로 작성되었습니다.

## 무선이동 네트워크

#### 1. 무선(wireless)

---

![8-1](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/401ead8e-c421-450f-ae8b-6d973368b61c)

- 일반 서브넷 구조와 유사하나 무선 네트워크를 지원하느 AP에 노드들이 무선으로 연결되어 있는 그림
- 보통 각 끝단의 노드들만 무선으로 연결되어 있다. ex. 노트북, 스마트폰- wifi
- 이러한 무선과 유선 상태가 동시에 존재하는 base station(AP)이 존재한다.

#### 2. 무선 링크의 특성

---

![8-2](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/e1668a74-1797-44f3-9ad7-b4d3a0f76c63)

- 유선 환경과 다르게 물리적인 거리가 멀어질수록 전송 신호가 급격하게 줄어든다.
- 외부 요인으로부터 데이터를 전송할 때 영향을 받을 위험이 존재한다.
- 우측 그래프에서 보이듯 A의 신호가 C까지 정상적으로 도달하지 못해서 유선상황에서 해왔던 충돌감지가 불가능하다.
- CSMA 사용이 불가능하다.
- 또한 A와 B의 데이터 이동이 C에게는 들리지 않으므로 다양한 문제가 발생한다.
- 따라서 기존 유선 링크계층과는 다른 프로토콜이 필요하다.

#### 3. IEEE 802.11 Wireless LAN (통칭 WIFI)

---

![8-3](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/a133186d-db91-43c7-86aa-0035704cc9cc)

- wirelessHost: 무선 호스트, 하나의 base station과 소통하는 호스트
- base station (Access Point), AP로 부른다 무선네트워크를 제공하는 주체.
- 이러한 AP에 wirelessHost가 달라붙어있는 네트워크 형태를 Basic Service Set(BSS)라고 부른다 (cell이라고도 부름).
- 그렇다면 우리는 어떻게 bss내부에 들어가서 AP와 소통할 수 있을까?

#### 4. Association

---

- 우리가 랩탑을 열어 주변 다양한 AP들중 하나를 골라 BSS에 속하는 과정, wifi에 연결하는 과정이다.
- AP들은 주변 host들에게 비콘(beacon frames)이라는 자기자신의 정보를 1초에 약 10번정도 계속해서 전파함으로써 자신을 알린다
- 호스트는 하나의 비콘을 골라 association Request frame을 보내고 AP는 association Respons frame으로 대답하여 연결한다.
- 그렇다면 wifi 네트워크에선 어떤 MAC프로토콜을 사용할까?

#### 5. wifi의 CSMA/CA(avoid)

---

- 기본적으로 wifi환경에서도 CSMA는 동작한다. 데이터 전송 전 carrier sense를 실행하고 데이터를 전송한다.
- 그러나 전송 도중에 충돌감지가 불가능하므로 우선은 무조건 중단없이 데이터를 전부 다 보낸다.
- 이후 데이터가 잘 전송되었는지 확인하기 위해서 수신자에게 ACK를 받아야만 한다. - 만약 피드백을 받지 못하면 유실로 판단하여 재전송을 한다.

  > 이때 ACK는 앞서 배운 TCP에서의 ACK와는 완전히 다른 ACK다. TCP의 ACK는 데이터의 최종 목적지에서 데이터 전송이 완료되었다고 알리는 ACK이고, 이번 장에서의 ACK는 한 홉 사이에서의 ACK 이다.

- 충돌이 생겼을 시 이더넷에 비해서 피해가 훨씬 크다. 재전송까지의 시간이 오래걸리고 사람이 많을수록 상황이 더욱 악화되기 때문이다.

#### 5. RTS-CTS를 통한 충돌 개선(ready-to-send, clear-to-send)

---

- rts와 cts는 자신이 데이터를 전송할 것이며 받을 준비가 완료되었다는 정보가 담긴 작은 용량의 데이터 프레임이다.
- 데이터를 주고받기 전 AP와 호스트가 rts와 cts를 주고받으면서 충돌을 최대한 회피하기 위한 노력이 RTS-CTS다.

![8-4](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/77049169-c2a5-4cb5-bf9c-c4d83a46aeb9)

- A와 B둘다 AP에게 데이터를 보내려는 상황. A B 모두 서로의 데이터 전송을 감지할 수 없는 상황이다.
- A와 B둘다 RTS를 AP에게 보내면 AP측에서 충돌이 일어나 CTS를 아무에게도 보내지 않는다.
- 이후 random backoff 대기 이후에 A가 먼저 RTS를 보내면 AP는 얼마나 통신할건지 등의 정보가 담긴 CTS를 다시 A에게 보내준다.
- 이때 링크 계층의 특성상 CTS는 BSS내부의 모든 노드들에게 전파되는데 이때 다른 노드들도 CTS를 옅듣고 A와 AP의 통신을 방해하지 않게 된다.
- AP가 A에게 이후 ACK를 보냄으로써 통신 종료

- RTS-CTS를 사용하면 정확히 무슨 장점이 있을까?
- 결국 둘 다 충돌은 발생할 수 있으나 충돌이 발생했을때 날아가는 데이터가 전체 프레임이냐 RTS냐의 차이가 있으므로 피해를 최소화 할 수 있다.

- 또한 CTS를 전파받아 대기해야하는 노드들은 데이터 전송을 위한 power를 꺼두는 부가기능도 존재한다.
  > 보통 데이터 통신이 가능한 기기에서 데이터 송/수신에 드는 전력량이 전체 소비 전력량의 대부분을 차지하므로 이러한 기능이 사용된다.

#### 6. Wifi의 Frame 구조

---

![8-5](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/5d3a3f1e-61dc-40fe-9523-95fa0492e565)

1. CRC: 에러 체크를 위한 필드
2. payload: data 영역, ip패킷이 들어갈 것이다.
3. address1: **해당 프레임을 받을 AP의 MAC Address**
4. address2: **송신 노드의 MAC Address**
5. address3: **해당 프레임을 받을 nxt hop의 MAC Address** (network계층의 관점에서의 nxt hop이다)
6. address4: 현실적으로 쓰이지 않음
7. frame control - type: 해당 프레임의 목적이 RTS, CTS, ACK, data중 어떤것인지 구분하는 필드, 실제 wifi의 frame 종류는 저 4가지중 하나다.

- 앞선 링크계층에서의 frame과 유사하나 차이점이 있다.
- frame의 특성상 hop과 nxt hop간의 전달만을 담당하므로 기존 frame에는 다음 목적지의 MAC주소만이 기입되어 있었다.
- 그런데 왜 MAC 주소가 3개나 존재하며 AP로 frame을 보내는데 유선 라우터의 MAC Address가 적혀있을까?

![8-6](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/b6a938b1-c3ea-49da-9803-7e2465354c1a)

- AP라는 기기는 기본적으로 유선환경과 무선환경이 동시에 존재하는 기기이며 **스위치처럼 링크계층까지만** 존재한다.
- 보통의 라우터간의 데이터 전달이라면 AP가 frame을 받으면 다음 목적지를 확정하기 위해 frame의 ip패킷을 참고해야만 한다.
- 하지만 AP는 링크계층까지만 존재하므로 이 방법을 사용할 수 없다.
- 앞서 배운 유선 링크 frame에 적혀있던 dest MAC addr가 의미하는 nxt hop은 **frame의 data영역을 처리할 수 있는 nxt hop**이라는 의미다.

- AP는 frame을 받았다고 한들 네트워크 계층도 없고 ip패킷을 확인할 수 도 없으며 forwarding table을 통해서 다음 목적지를 설정할 수도 없으므로 이러한 AP의 특수성 때문에 다음 라우터의 MAC addr까지도 기입되어 있는거다.

#### 7. 일상생활 속 무선 wifi 공유기의 역할

---

- 실제 가정에서 쉽게 볼수있는 wifi 공유기라 함은 종합적인 다양한 기능이 모두 합쳐져있다.

1. AP와 라우터의 기능을 동시에 수행한다. 따라서 호스트가 frame을 보낼때 address1과 address3의 MAC주소가 같다
2. 우리가 wifi공유기를 통해 인터넷에 연결해야하므로 DHCP 서버가 돌아가고 있고 이는 애플리케이션 서버까지 구현되어 있음을 뜻한다.
3. 추가적으로 DNS서버까지 탑재되어있는 경우가 많으며 종합적으로 이 공유기가 한 가정 네트워크의 게이트웨이 라우터의 기능을 한다.

#### 8. Mobility: 이동

---

![8-7](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/a967e972-6710-491e-ba41-4a92364c7362)

- 서브넷에 스위치로 노드들이 연결되어 있고 같은 서브넷 내에 2개의 AP가 존재한다.
- 두 AP는 개념상 각각의 BSS를 이루지만 모두 같은 서브넷이다. (ip주소가 같음)
- AP1과 AP2는 모두 같은 서브넷이지만 스위치에 연결된 output link가 다르다.
- 이때 AP1을 통해 통신중이던 기기 H1이 데이터를 받는 도중에 AP2로 옮겨간다면 어떻게 통신이 중단되지 않고 무사히 H1으로 데이터가 도착할까?
- 정답은 앞서 배운 스위치의 self-learning에 있다.
- H1이 Ap2에 연결되는 순간 스위치는 switch table의 H1의 대한 정보(output link에 대한 정보)를 즉시 바꿈으로써 데이터 통신을 정상적으로 수행한다.

> 좀 더 구체적으로 알아보자.

- H1이 앞의 상황에서 구글 서버와 Tcp통신을 맺은 상황이었다. 그때 Ap연결의 이동이 일어났는데 어떻게 Tcp연결이 끊기지 않고 정상수행되었을까?
- 앞서 배웠던 TCP통신의 특징을 다시 떠올려보자.
- TCP통신이란 연결된 Tcp 소켓간의 데이터 이동이고 결국 이 소켓 연결이 끊기지 않으면 데이터 통신은 수행된다.
- 다시 되짚어보면 TCP소켓의 인덱싱은 다음과 같은 4가지 조건을 통해서 이루어진다

1. source ip address
2. source port num
3. dest ip address
4. dest port num

- 위 4가지 사항만 변하지 않으면 tcp연결이 끊어질 이유가 없다.
- 당연히 위의 상황에서 dest ip/port는 변하지 않으며 같은 서브넷의 AP연결만이 바뀌므로 source의 ip주소와 port번호도 바뀌지 않는다.
- 이 때문에 ap를 옮겨도 tcp연결이 끊어지지 않게 통신이 가능하며 무선 이동 네트워크라 칭할 수 있는것이다.
  > 다른 서브넷으로 옮긴다면 당연히 연결은 끊긴다.
