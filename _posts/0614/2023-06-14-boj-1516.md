---
title: "BOJ 1516 게임 개발 C++"

categories:
  - Algorithm
tags:
  - Algorithm
---

## BOJ 1516 게임 개발 C++

문제

> 숌 회사에서 이번에 새로운 전략 시뮬레이션 게임 세준 크래프트를 개발하기로 하였다. 핵심적인 부분은 개발이 끝난 상태고, 종족별 균형과 전체 게임 시간 등을 조절하는 부분만 남아 있었다.
> 게임 플레이에 들어가는 시간은 상황에 따라 다를 수 있기 때문에, 모든 건물을 짓는데 걸리는 최소의 시간을 이용하여 근사하기로 하였다. 물론, 어떤 건물을 짓기 위해서 다른 건물을 먼저 지어야 할 수도 있기 때문에 문제가 단순하지만은 않을 수도 있다. 예를 들면 스타크래프트에서 벙커를 짓기 위해서는 배럭을 먼저 지어야 하기 때문에, 배럭을 먼저 지은 뒤 벙커를 지어야 한다. 여러 개의 건물을 동시에 지을 수 있다.
> 편의상 자원은 무한히 많이 가지고 있고, 건물을 짓는 명령을 내리기까지는 시간이 걸리지 않는다고 가정하자.

입력

> 첫째 줄에 건물의 종류 수 N(1 ≤ N ≤ 500)이 주어진다. 다음 N개의 줄에는 각 건물을 짓는데 걸리는 시간과 그 건물을 짓기 위해 먼저 지어져야 하는 건물들의 번호가 주어진다. 건물의 번호는 1부터 N까지로 하고, 각 줄은 -1로 끝난다고 하자. 각 건물을 짓는데 걸리는 시간은 100,000보다 작거나 같은 자연수이다. 모든 건물을 짓는 것이 가능한 입력만 주어진다.

출력

> N개의 각 건물이 완성되기까지 걸리는 최소 시간을 출력한다.

---

_풀이_

문제를 읽으면 위상정렬 알고리즘인 것을 어렵지 않게 파악할 수 있다.  
보통의 위상정렬과 차이점은 각 건물의 순서를 요구하는것이 아닌 건물의 최소 건설 시간을 구하는 것.  
나는 우선 기존 위상정렬에서 queue에 좌표를 담던것을 조금 변형해서 *우선순위 큐(pq)*를 사용해서 문제를 해결했다.  
pq에는 pair<int,int> 로 2가지 값이 저장된다.
_{해당 건물이 건설되는데 걸리는 시간, 건물 번호}_ 의 식으로 우선순위 큐에 넣어주면 _건물이 건설되는것이 빠른 순으로 큐에서 나오게 된다._
이 점을 알아두고 과정을 설명하겠다.

1. 우선 degree가 0인 노드들을 {자신의 건설시간, 건물 번호}의 형태로 우선순위 큐에 넣는다.
2. 그 후 우선순위 큐에서 노드들을 하나씩 뽑으면서 큐에서 나온 건물들의 건설시간을 ans[] 배열에 기록하고 노드와 연결된 degree를 줄여나간다.
3. 이때 degree가 0이 된 건물번호를 i라고 할때, 우선순위 큐에 {i의 건설 시간 + 이전 건물까지의 건설시간, i}의 형태로 넣어준다.
4. 큐가 빌때까지 2-3번을 반복한다.

이렇게 풀이한다면 이론적으로 건설 우선순위를 전부 고려해서 가장 빠른 건설속도가 ans 배열에 기록된다.

과정이 이해가 가지 않는다면 큐에서 뽑히는 노드의 순서와 시간을 출력하면서 코드를 돌려보면 이해가 쉽게 갈 것이다.

아래는 풀이 코드다.

---

```c++

vector<int> adj[505];
int dg[505];
int t[505];
int ans[505];
int n;

int main(void) {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> t[i];
        while (1) {
            int a;
            cin >> a;
            if (a == -1) break;
            adj[a].push_back(i);
            dg[i]++;
        }
    }

    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    for (int i = 1; i <= n; i++) {
        if (dg[i] == 0) pq.push({ t[i], i});
    }

    while (!pq.empty()) {
        auto cur = pq.top(); pq.pop();
        //cout << cur.Y << " " << cur.X << '\n';
        ans[cur.X] = cur.Y;
        for (auto i : adj[cur.X]) {
            dg[i]--;
            if (dg[i] == 0) pq.push({ ans[cur.X] + t[i], i});
        }
    }

    for (int i = 1; i <= n; i++) {
        cout << ans[i] << '\n';
    }


}

```
