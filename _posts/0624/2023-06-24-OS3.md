---
title: "운영체제2: 하드웨어 시스템 구조와 프로그램 실행의 원리 1"

categories:
  - OS
tags:
  - OS
---

> 이 글은 KOCW에서 제공하는 이화여자대학교 반효경 교수님의 운영체제 강의를 기반으로 내용을 정리하고 복습하기 위한 용도로 작성되었습니다.

## 하드웨어 시스템 구조와 프로그램 실행의 원리

> 컴퓨터 시스템 구조, Mode bit, Timer, Device Controller, 입출력(I/O)의 수행, 동기식 입출력과 비동기식 입출력, 시스템콜(System Call), 인터럽트(Interrupt)

#### 1. 컴퓨터 시스템 구조

---

![10-6](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/5dd223fd-dd29-46dc-81c4-32c968b97eb1)

- cpu와 메모리로 구성된 컴퓨터 부분과 io디바이스들로 구성되어있다.
  > io 디바이스에서 컴퓨터로 데이터를 입력하는것을 input, 컴퓨터가 디바이스에 결과를 보내는것을 output이라 한다.
- 메모리는 cpu의 작업공간으로 cpu는 매 단위시간마다 메모리에서 기계어를 하나씩 읽어서 실행한다.

좀 더 자세한 그림
![10-7](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/f300e4e4-8b14-4eaf-ae6f-7fdd1b974462)

#### 2. CPU와 I/O 디바이스

---

- **CPU**
- cpu내부에는 메모리보다 더 빠르면서 정보를 저장할 수 있는 register가 존재한다 (program counter: PC). cpu는 이 레지스터에 적힌 메모리의 주소에서 정보를 읽어와 자신이 다음에 수행할 명령을 수행한다.
- cpu에서 현재 실행하는것이 운영체제인지 사용자 프로그램인지 구분하기 위한 mode bit이라는 필드도 존재한다.

- **Device controller와 Local Buffer**
- 각각의 io디바이스는 디바이스의 기능을 전담하는 작은 cpu로 device controller가 존재한다.
- 또한 메인 cpu가 작업공간으로 메모리가 필요하듯 device controller도 local buffer라는 작은 메모리를 가지고있다.
  > divece driver는 OS코드 중 디바이스의 인터페이스를 접근할 수 있게 도와주는 일종의 드라이버 역할을 하는 소프트웨어다. 아래에서 자세히 설명한다.
- cpu는 메모리에 적혀있는 작업만을 진행한다. 그러던중 프로그램이 io를 사용하는 경우가 있을 수 있는데 그때는 cpu가 직접 io와 상호작용 하는것이 아닌 OS에게 권한을 위임하여 OS가 io의 controller에 작업을 명령한다.
- io의 작업속도는 cpu와 비교해서 굉장히 느린데 cpu는 io에게 작업을 위임한 후 결과를 기다리지 않고 다른 수행가능한 작업을 이어서 수행한다.

#### 3. timer와 Timer Inturrupt

---

- 메모리에 있는 특정 프로그램이 무한루프를 도는 등 cpu의 자원을 독점하려는 현상이 발생하는것을 방지하기 위해 timer라는 하드웨어가 내부에 별도로 존재한다.
- 컴퓨터가 부팅되면 초기에 OS만이 메모리에 존재하다가 다른 프로그램이 실행되면 OS가 cpu의 자원을 조금씩 나눠준다.
- 이때 cpu자원 독점을 방지하기 위해 timer에 프로그램마다 제한시간을 걸어두고 제한된 시간에 도달하면 timer가 cpu의 interrupt line에 timeout이 된 프로그램이 있다고 알려준다. (timer inturrupt) (OS는 프로그램에게 cpu의 자원을 나눠줄 수는 있지만 다시 빼았을수는 없다.)
- cpu는 작업을 수행하면서 interrupt line에 timeout된 프로그램이 있는것을 확인하면 다시 OS에게 cpu의 자원을 되돌려준다.
- 이후 OS는 돌려받은 자원을 다른 프로그램에게 넘겨주면서 cpu의 사용권한을 timer의 도움을 받아 균등하게 분배한다.
- 굳이 무한루프에 의한 timeout이 아니어도 일반적으로 프로그램이 종료되어도 위와같은 방법으로 cpu의 자원이 순환된다.

#### 4. IO Device의 Hardware Interrupt

---

- 또한 프로그램이 cpu를 사용하지않고 io디바이스와 상호작용을 해야할 때는 OS에게 자진해서 cpu자원을 넘겨준 후 io디바이스에 접근할것을 요청한다.
  > 모든 입출력 명령은 특권명령이다. 프로그램은 자의로 io디바이스에 접근할 수 없다. OS를 거쳐서 접근해야 한다.
- 이후 io컨트롤러가 요청된 작업을 완료하면 디바이스 컨트롤러가 CPU에 interrupt를 걸어서 작업이 완료되었음을 알린다.
- 그러면 cpu는 잠시 작업을 멈추고 OS에게 제어권이 넘어간다.
- OS는 해당 작업을 요청한 프로그램의 메모리에 io 결괏값을 copy해주고 마저 진행중이던 작업이 끝나면 해당 프로그램에게 cpu사용권을 부여할 수 있도록 조정한다.

#### 5. Modebit

---

- cpu내부의 상태필드.
- 사용자 프로그램의 잘못된 수행을 방지하기 위한 일종의 권한 코드.
- modebit 0 = 모니터 모드, cpu가 OS코드를 수행중. (=커널 모드)
- modebit 1 = 사용자 모드, 사용자 프로그램을 수행중.

- modebit이 0일때 즉 운영체제가 실행중일때는 운영체제에 cpu권한이 있기때문에 메모리접근, io디바이스 등 모든 기능에 대한 권한이 열려있다.
- 1일때는 제한된 기능만 cpu에서 사용할 수 있게 설정되어있다.

#### 6. DMA(Direct Memory Access) Controller와 Interrupt 관리

---

- 위의 내용을 종합해보면 cpu는 다양한 io디바이스로부터 interrupt를 받을일이 너무나도 많다.
- interrupt가 너무 많아지면 cpu의 작업속도가 느려지는데 이런 io디바이스의 interrupt를 관리하기 위해 등장한것이 바로 DMA다.
- DMA의 등장으로 이제 io장치가 작업을 끝낸후 cpu에게 바로 인터럽트를 걸지 않고 DMA에게 결괏값을 전달한다.
- DMA는 메모리 접근권한을 가지고있어 결괏값을 알맞은 메모리에 copy해주고 해당 사실을 모아놨다가 한번에 cpu에게 알려줌으로써 cpu의 인터럽트 혼잡을 관리해준다.

> 이때 DMA와 cpu가 동시에 메모리에 접근하여 일관성 문제가 생길수 있기에 memory controller가 이를 관리해준다.

#### 7. 입출력(IO)의 수행과 시스템 콜

---

- 모든 입출력 명령은 특권명령이다. 프로그램은 자의로 io디바이스에 접근할 수 없다. OS를 거쳐서 접근해야한다.
- 이처럼 사용자 프로그램이 운영체제(커널)의 함수를 호출하는것을 System call이라고 한다.
- 사용자 프로그램이 시스템콜을 호출하는 과정은 다음과 같다.

1. 사용자 프로그램 수행 중 io입력을 위해 시스템콜을 호출해야한다.
2. 하지만 시스템 콜은 OS인터페이스인데 cpu가 사용자 프로그램을 수행중일때는 modebit이 1이므로 OS에 접근할 수 없다.
3. 따라서 사용자는 직접 cpu의 interrupt line에 인터럽트를 걸어줘 자신이 io장치를 사용해야함을 알린다.
4. 인터럽트가 걸리면 cpu의 권한이 OS에 넘어가고 이때 OS가 시스템콜로 io장치에게 대신 명령한다
5. 이후 과정은 위에 설명된 DMA와 io device 설명과 같다. (하드웨어 인터럽트가 걸림)

- 이렇듯 시스템콜 함수의 호출과 일반 프로그램의 함수 호출은 구조적으로 다르다. - 일반함수는 메모리 내에서 명령의 주소만 바뀌지만 시스템콜은 좀 더 복잡한
  과정이 일어난다.

- 또한 위와같이 소프트웨어측에서 인터럽트를 거는것을 trap이라고 하며 하드웨어가 cpu에게 인터럽트를 거는것을 interrupt라고 표현한다.

---

지금까지의 내용을 정리해보면 인터럽트는 총 3가지가 있다.

1. 사용자 프로그램이 io장치를 사용하기위해 시스템콜을 걸때 발생하는 trap
2. io디바이스가 작업을 마쳤음을 cpu에게 알리는 interrupt
3. 작업에 할당된 시간이 끝났음을 알리는 timer interrupt

현대의 운영체제는 이렇게 interrupt에 의해서 구동된다.  
평상시 cpu는 거의 대부분 사용자 프로그램에게 점유되고 있다가 인터럽트가 발생할때만 OS에게 Cpu의 사용권한이 넘어가며 동작하기 때문이다.

> 인터럽트 벡터: 해당 인터럽트의 처리 루틴 주소를 가지고 있다.
> 인터럽트 처리 루틴: 해당 인터럽트를 처리하는 커널 함수(= 인터럽트 핸들러)
