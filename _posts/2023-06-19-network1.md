---
title: "네트워크 5-2 링크 계층: MAC과 ARP"

categories:
  - Network
tags:
  - Network
---

> 이 글은 KOCW에서 제공하는 한양대학교 이석복 교수님의 컴퓨터 네트워크 강의를 기반으로 내용을 정리하고 복습하기 위한 용도로 작성되었습니다.

## MAC과 ARP

#### 1. Ethernet 이더넷

---

- 이더넷은 현재 링크 계층에서 가장 많이 쓰이는 기술중 하나다.

- 이더넷의 Frame format은 다음과 같다.

![7-1](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/3d01db1a-d091-4154-ba9b-ab66e693fbca)

1. CRC: Error ditection을 위한 필드
2. data: ip패킷이 들어가는 필드
3. dest address, source address: MAC address, ip주소와는 다르다
4. type: 상위 계층이 어떤것인지 명시하기 위한 필드 (99%로 ip 프로토콜이 적힘)

#### 2. 이더넷의 CSMA/CD

---

- 링크계층에서는 피드백이 존재하지 않는다. 즉 데이터를 전달받은 라우터 혹은 노드는 전달받은 데이터에 대해 잘 전달받았는지 피드백을 주지 않는다.
- 유선 링크계층은 외부로부터 보호받는 환경에서 데이터가 전달되기 때문에 충돌감지에 의해 충돌이 감지되지 않는다면 100% 데이터가 잘 전달되었다고 확신할 수 있기 때문에 피드백이 필요없다.
- 대신 그만큼 100% 충돌을 감지할 수 있어야만 한다.
- 다행히도 유선상황에서 링크를 자신만 사용하고 있는지 확인하는것은 어렵지 않기 때문에 충돌감지는 쉬운편이다.
- 그런데 혹시라도 충돌을 감지하지 못하는 경우는 어떤 경우가 있을까?

#### 3. 이더넷 충돌감지의 코너 케이스

---

- A와 B가 한 링크에서 데이터를 전송하려고 한다.
- A가 링크가 조용한것을 확인하고 데이터를 보냈다 하지만 해당 전파가 B에게 닿기전 B도 링크가 조용한것을 확인하고 데이터를 보냈기에 충돌이 일어났고 B는 이사실을 확인하는 즉시 전송을 멈췄다.
- B가 이미 보낸 데이터는 주워담을 수 없기에 계속 전송되며 이는 A가 충돌을 감지하기 위한 데이터로 사용되어야 한다.
- 하지만 B의 데이터가 A에게 닿기 전에 A가 전송을 마치면 A는 충돌이 일어나지 않았다고 판단하게된다.

- **이는 A가 너무빨리 대화를 마쳤기 때문이다.** A가 조금 더 오래 대화를 하고 있었다면 중간에 B의 데이터가 감지되고 충돌을 알 수 있었을것이다.

- 따라서 링크계층에서는 이러한 상황을 방지하기 위한 최소한의 프레임사이즈가 존재하는데 이를 **Minimum Frame Size(64Byte)**라고 한다.
  > 왜 64바이트인지는 충돌 감지를 위한 과학적 공식이 있으나, 공식이 핵심이 아니라 이런 최솟값이 존재하는 시나리오를 이해하는것이 중요하다.
- 내가 보내고자 하는 Frame의 원래 size가 64바이트보다 작다면 뒤에 padding으로 64바이트까지 채워서 충돌을 감지하는데 사용한다.

- 이런식으로 링크 계층은 충돌을 반드시 감지해야하기에 Minimum Frame Size가 존재해야하는 배경이 있음을 알아둬야 한다.

#### 4. MAC addresses

---

- 링크 계층에서 사용하는 주소체계이다.
- 네트워크 통신을 하는 하드웨어에 할당된 48비트 주소로 ip주소나 hostname처럼 바뀌지 않으며 모든 네트워크 기기마다 고유하다.
  > 앞서 ip주소는 연결되는 네트워크 인터페이스에 따라서 달라진다고 공부했다. - MAC주소는 이런 네트워크 인터페이스 소켓 자체에 부여된 번호로써 다른 어떤 서브넷에 연결되더라도 고유하다는 특징이 있다.
  > LAN카드에 적힌 번호라고 이해하면 이해하기 쉽다.

#### 5. ARP

---

- 우리가 구글에 데이터를 전송해야하는 상황을 가정해보자.
- 앞서 DNS서비스를 통해서 구글의 ip주소를 알아냈으며 각 계층에 역할에 따라서 데이터가 내려와 링크계층에까지 전달되었다.
- 링크계층의 Frame안에 데이터를 넣고 목적지의 MAC주소와 출발지의 MAC주소를 적어야 한다. 목적지의 MAC주소를 어떻게 알 수 있을까?
  > 이때 목적지의 MAC주소라 함은 최종 목적지가 아닌 다음 hop의 MAC주소를 뜻한다.
- 우리가 사용하는 컴퓨터는 네트워크 내부에서 하나의 노드이며, 각 노드는 목적지를 향할때 거칠 next hop이 담겨있는 forwarding table을 네트워크 계층에서 가지고있다고 공부했다.
- 이때 우리는 서브넷에 소속되므로 next hop이 게이트웨이 라우터일것이다.
- 우리는 네트워크에서 ip주소를 부여받을때 DHCP라는 프로토콜을 통해서 게이트웨이의 ip주소를 받았다.
- 이때 받은 게이트웨이의 ip주소를 MAC주소로 변환하는것이 바로 ARP이다.

#### 6. ARP의 동작 과정: Self-learning

---

- 링크 계층에는 ARP table이란것이 존재한다.
- ARP table은 같은 네트워크 안 host들의 ip주소와 MAC주소가 맵핑되어있는 테이블이다.
- 이런 ARP table은 초기에 비어있을것이고 우리는 처음부터 게이트웨이의 ip주소로 MAC주소를 얻을 수 없다.
- 이때 테이블을 채우기 위해서 네트워크 내부에 찾고있는 ip주소의 MAC주소를 알려달라는 브로드 캐스트를 보내는데 이를 ARP query라고 한다.
- ARP query는 Frame의 형태로 전송되며 받아야하는 대상의 dest MAC주소를 알 수 없으므로 Frame의 dest MAC address에는 브로드캐스트 MAC address를 사용한다.
  > ex FF-FF-FF-FF-FF-FF
- 해당 ARP query를 받은 노드들은 자신의 ip주소와 일치한다면 자신의 MAC주소를 ARP response를 응답해주고 우리는 next hop의 MAC주소를 table에 채울 수 있다.

  > ttl이 존재하여 하루가 지나면 사라진다.

- 그 후로부터 우리는 frame을 완성하여 링크를 통해 연결된 모든 노드들에게 frame을 전파하고 MAC주소가 맞는 hop이 이를 받아 위의 과정을 반복하여
  목적지까지 데이터가 전달된다.

#### 7. 전체적인 데이터 전송과정

---

![7-2](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/97e8e5a4-ad9e-44d9-a663-f8610eab2106)
![7-3](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/743f8ec2-89cb-4bf4-9a9b-c2d06699d98d)
![7-4](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/a013c08c-5c34-477b-9ebf-3691a9644550)
![7-5](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/e6b3455c-53cc-4444-a765-91fc749b2b00)
![7-6](https://github.com/mjh851819/mjh851819.github.io/assets/70308520/86316569-dfef-4453-9a2a-f1ff6ac01e58)

- 여기까지 학습했다면 데이터의 전체적인 전송과정을 반드시 이해할 수 있어야한다 ppt의 과정을 충분히 이해하고 넘어가자.
- 주목할점은 아래와 같다.

1. DNS를 사용하여 B의 ip주소를 알아낸다.
2. forwarding table을 통해서 B의 ip로 가기 위한 next hop의 ip주소를 알아낸다. (네트워크 계층에서 작성된 table)
3. ARP table을 통해서 next hop의 ip로 next hop의 MAC주소를 얻는다.

- 생각해봐야 할 점

1. A는 어떻게 B의 ip주소를 알 수 있을까?
2. A는 어떻게 첫번째로 도착할 hop router 'R'의 IP주소를 알 수 있을까?
3. A는 어떻게 R의 MAC주소를 알 수 있을까?

- 정답: 각각 DNS, forwarding table과 DHCP, ARP를 통해서 알 수있다.
